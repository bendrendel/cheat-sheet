<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures</title>
</head>
<body>
    <a href="../index.html">Home</a>

    <h1>Data Structures</h1>

    <h2>Basics</h2>
    <ul>
        <li>The backbone of every piece of software is data and algorithms.</li>
        <li>Data structures are how data is stored and retrieved, including inputting,
            processing, maintaining, and retrieving data.  Their usefulness comes from 
            resembling the way data will be used.
        </li>
        <li>Picking a data structure depends on the intended purpose for the data,
            whether you need memory to be statically or dynamically allocated, and
            the speed at which the data structure can accomplish intended tasks.
        </li>
    </ul>

    <h2>Nodes</h2>
    <ul>
        <li>Nodes are the building block of many data structures</li>
        <li>A node is a piece of data (of any data type) and one or more links (called pointers) to other nodes. Pointers can be null, indicating the end of a path of nodes</li>
        <li>Orphaned nodes are nodes which no other node has a pointer to.  This means they can't
            be accessed and can happen if you mishandle adding, deleting, or modifying nodes.
        </li>
        <li>In javascript, nodes can be implemented using a class (example below) with a data property and a next property. The data can accept any data type, and the next property should only be allowed to be set to another instance of the node class.</li>
        <li>With this structure, you can do things like loop through nodes that are linked to one another by using their next property to set a variable in the loop to the next node
            <code><pre>
            class Node {
                constructor(data) {
                    this.data = data;
                    this.next = null;
                }

                setNextNode(node) {
                    if (!(node instanceof Node)) {
                    throw new Error('Next node must be a member of the Node class');
                    }
                    this.next = node;
                }

                getNextNode() {
                    return this.next;
                }
            }

            module.exports = Node;
        </pre></code></li>
    </ul>

    <h2>Linear Data Structures</h2>
    <h3>Singly Linked Lists</h3>
    <ul>
        <li>Singly Linked lists are a an ordered series of nodes that each link to a single other node.  The first node, which no other node links to, is the head node, and the last node, which has a null link, is the tail node. The linked list really is nothing more than a pointer to the head node. Singly linked lists can be thought of as having a direction.</li>
        <li>Common operations are adding a new node to the linked list by adding it to the beginning of the list, i.e. giving it a pointer to the current head node.  Also, you may need to remove a node in the middle of the linked list, which requires you to change the pointer of the node pointing to the removed node, to the node the removed node is pointing to.</li>
        <li>Many linked list problems require you to iterate through the linked list nodes, e.g. until
            a given data value is found.  For many problems, it is helpful to iterate through the linked list with two pointers simultaneously.  E.g. a pointer that moves through the list two nodes at a time, and one the moves through one at a time, which could allow you to find the middle of the list as once the double-speed pointer gets to the end of the list, the single-speed pointer will be in the middle of the list.  Or to get the nth-last item in the list, you have one pointer iterate through to the end of the list, while another pointer iterates through, n nodes behind the first pointer.
        </li>
        <li>The benefit of a linked list over an array is that it is faster to add things to it, whether to the beginning, end or middle of the list.  JS automatically allocates contiguous blocks of memory for an array, and when you add to it, it may need to reallocate memory somewhere else if there isn't memory available next to the current block.  This requires copying everything in the array to a new location.  Even if there is space available, if you want to insert into the middle of the array, then it needs to move everything over in memory after the location you insert to.  Likewise if you delete from the middle of the array then it has to move over everything in memory to fill in the deleted space.  Linked lists don't have to do any reallocation of memory, adding and inserting is always merely a matter of updating pointers.  On the other hand, arrays are beneficial becuase the support direct access, i.e. you can simply use an index number to access part of an array, whereas linked lists always require sequential access, i.e. you have to start at the head and follow the pointers until you get where you want.</li>
        <li>This can be implemented with a class in javascript, like this basic example below. Linked lists can have many other methods besides below that allows you to quickly do various things.
            <code><pre>
            const Node = require('./Node');

            class LinkedList {
                constructor() {
                    this.head = null;
                }

                addToHead(data) {
                    const newHead = new Node(data);
                    const currentHead = this.head;
                    this.head = newHead;
                    if (currentHead) {
                        this.head.setNextNode(currentHead);
                    }
                }

                addToTail(data) {
                    let tail = this.head;
                    if (!tail) {
                        this.head = new Node(data);
                    } else {
                        while (tail.getNextNode() !== null) {
                            tail = tail.getNextNode();
                        }
                        tail.setNextNode(new Node(data));
                    }
                }

                removeHead() {
                    const removedHead = this.head;
                    if (!removedHead) {
                        return;
                    }
                    this.head = removedHead.getNextNode();
                    return removedHead.data;
                }

                deleteWithValue(data) {
                    if (!this.head) {
                        return
                    }

                    if (this.head.data === data) {
                        this.head = this.head.getNextNode();
                        return;
                    }

                    let currentNode = this.head;

                    while(currentNode.getNextNode()) {
                        if(currentNode.getNextNode().data === data) {
                            currentNode.setNextNode(currentNode.getNextNode().getNextNode());
                            return;
                        }
                        currentNode = currentNode.getNextNode();
                    }
                }

                printList() {
                    let currentNode = this.head;
                    let output = '&lthead> ';
                    while (currentNode !== null) {
                        output += currentNode.data + ' ';
                        currentNode = currentNode.getNextNode();
                    }
                    output += '&lttail>';
                    console.log(output);
                }
            }

            module.exports = LinkedList;
        </pre></code></li>
    </ul>

    <h3>Doubly Linked Lists</h3>
    <ul>
        <li>A doubly linked list is an ordered series of nodes, each with a link to the next node in the list and the previous node in the list.  The first node is the head and has a null value for its pointer to the previous node, and the last node is the tail with a null value for its pointer to the next node. Unlike a singly linked list, the doubly linked list consists of a pointer to both the head node and the tail node.  An example of a double linked list is your browser history, where the first page you visit is the head, and subsequent pages are added to the tail, then you can traverse back and forward. Doubly linked lists can be though of as bi-directional.</li>
        <li>Operations like adding/removing the head/tail, or inserting/removing in the middle are more complicated than singly linked lists because you need to update both the previous and next pointers of each node.  However, it can be easier with tail operations since you have a pointer to the current tail to start at, instead of having to iterate through everything to find the tail.</li>
        <li>A circular linked list is one where the previous pointer of the head points to the tail, and the next pointer of the tail points to the head.</li>
        <li>An example implementation is below. The imported Node would be similar to above except it would have a previous property, and setPreviousNode and getPreviousNode methods.
            <code><pre>
            const Node = require('./Node');

            class DoublyLinkedList {
                constructor() {
                    this.head = null;
                    this.tail = null;
                }

                addToHead(data) {
                    const newHead = new Node(data);
                    const currentHead = this.head;
                    if (currentHead) {
                        currentHead.setPreviousNode(newHead);
                        newHead.setNextNode(currentHead);
                    }
                    this.head = newHead;
                    if (!this.tail) {
                        this.tail = newHead;
                    }
                }

                addToTail(data) {
                    const newTail = new Node(data);
                    const currentTail = this.tail;
                    if (currentTail) {
                        currentTail.setNextNode(newTail);
                        newTail.setPreviousNode(currentTail);
                    }
                    this.tail = newTail;
                    if (!this.head) {
                        this.head = newTail;
                    }
                }

                removeHead() {
                    const removedHead = this.head;
                    if (!removedHead) {
                        return;
                    }
                    this.head = removedHead.getNextNode();
                    if (this.head) {
                        this.head.setPreviousNode(null);
                    }
                    if (removedHead === this.tail) {
                        this.removeTail();
                    }
                    return removedHead.data;
                }

                removeTail() {
                    const removedTail = this.tail;
                    if (!removedTail) {
                        return;
                    }
                    this.tail = removedTail.getPreviousNode();
                    if (this.tail) {
                        this.tail.setNextNode(null);
                    }
                    if (removedTail === this.head) {
                        this.removeHead();
                    }
                    return removedTail.data;
                }

                removeByData(data) {
                    let nodeToRemove;
                    let currentNode = this.head;
                    while (currentNode !== null) {
                    if (currentNode.data === data) {
                        nodeToRemove = currentNode;
                        break;
                    }
                    currentNode = currentNode.getNextNode();
                    }
                    if (!nodeToRemove) {
                        return null;
                    }
                    if (nodeToRemove === this.head) {
                        this.removeHead();
                    } else if (nodeToRemove === this.tail) {
                        this.removeTail();
                    } else {
                        const nextNode = nodeToRemove.getNextNode();
                        const previousNode = nodeToRemove.getPreviousNode();
                        nextNode.setPreviousNode(previousNode);
                        previousNode.setNextNode(nextNode);
                    }
                    return nodeToRemove;
                }

                printList() {
                    let currentNode = this.head;
                    let output = '&lthead> ';
                    while (currentNode !== null) {
                        output += currentNode.data + ' ';
                        currentNode = currentNode.getNextNode();
                    }
                    output += '&lttail>';
                    console.log(output);
                }
            }

            module.exports = DoublyLinkedList;
        </pre></code></li>
    </ul>

    <h3>Queues</h3>
    <ul>
        <li>Queues are a series of nodes that only allows for adding to the tail (enqueue) and removing from the head (dequeue), as well as peek (reveal head without removing it). They can be implemented using various underlying data structures, but it is common to implement them as a linked list.  The linked list would store a reference to the head and tail, so that enqueue and dequeue can be done without traversal, and would not allow any methods of traversal or modification.</li>
        <li>Queues behave like people waiting in a line, where the front of the line is the head and the back is the tail.  They are a first-in first-out (FIFO) structure.</li>
        <li>Bounded queues have a limit to the number of nodes allowed.  Queue overflow occurs on a bounded queue if you try to enqueue past that limit.  Queue underflow can happen to bounded or non-bounded queues, and is when you try to dequeue from an empty queueu.</li>
        <li>Queues are used in breadth first search, job schedulers, print jobs, and recording and executing keyboard input.</li>
        <li>Example implementation:
            <code><pre>
            const LinkedList = require("./LinkedList");

            class Queue {
                constructor(maxSize = Infinity) {
                    this.queue = new LinkedList();
                    this.maxSize = maxSize;
                    this.size = 0;
                }

                isEmpty() {
                    return this.size === 0;
                }

                hasRoom() {
                    return this.size &lt this.maxSize;
                }

                enqueue(data) {
                    if (this.hasRoom()) {
                        this.queue.addToTail(data);
                        this.size++;
                    } else {
                        throw new Error("Queue is full!");
                    }
                }

                dequeue() {
                    if (!this.isEmpty()) {
                        const data = this.queue.removeHead();
                        this.size--;
                        return data;
                    } else {
                        throw new Error("Queue is empty!");
                    }
                }
            }

            module.exports = Queue;
        </pre></code></li>
    </ul>

    <h3>Stacks</h3>
    <ul>
        <li>Stacks are a series of nodes that only allows for adding to the head (push) and removing from the head (pop), as well as peek to look at head without removing.  They can be implemented using arrays and other data structures, but using a linked list is the most efficient way to do it.</li>
        <li>Stacks behave like a stack of book, with top of stack as the head and bottom of stack the tail, they are a Last-In First-Out (LIFO) structure</li>
        <li>Stacks can have a size limit, if you try to push onto a stack past its size limit it will cause stack overflow, and if you try to pop from an empty stack it will cause stack underflow</li>
        <li>They are used in browser forward/back buttons, or undo/redo list</li>
        <li>Here is an example implementation:
            <code><pre>
                const LinkedList = require('./LinkedList');

                class Stack {
                    constructor(maxSize = Infinity) {
                        this.stack = new LinkedList();
                        this.maxSize = maxSize;
                        this.size = 0;
                    }

                    hasRoom() {
                        return this.size &lt this.maxSize;
                    }
                    
                    isEmpty() {
                        return this.size === 0;
                    }

                    push(value) {
                        if (this.hasRoom()) {
                            this.stack.addToHead(value);
                            this.size++;
                        } else {
                            throw new Error('Stack is full');
                        }
                    }

                    pop() {
                        if (!this.isEmpty()) {
                            const value = this.stack.removeHead();
                            this.size--;
                            return value;
                        } else {
                            throw new Error('Stack is empty');
                        }
                    }

                    peek() {
                        if (!this.isEmpty()) {
                            return this.stack.head.data;
                        } else {
                            return null;
                        }
                    }
                }

                module.exports = Stack;
            </pre></code>
        </li>
    </ul>

    <h2>Complex Data Structures</h2>
    <h3>Hash Maps</h3>
    <ul>
        <li>A Hash Map is a way of storing unique key-value pairs using an array of a fixed length and a hashing function.  The hashing function maps each key-value pair to an array index.  For multiple key-value pairs mapped to the same array index, a collision strategy is used.  It makes for faster retrieval of a key's value than if they were all stored in a linked list and you had to iterate through all list nodes. It allows for faster insertion/deletion time than if all the key value pairs were stored in an array and you had to constantly reallocate memory.</li>
        <li>A map, mathematically is synomous with function.  In computer science context, it means associating unique keys with a value.</li>
        <li>Hashing or Hash Functions take a string or other data and return an array index.  They map a large input domain (hash table keys) to a smaller output range (hash buckets, which are integer indices for an array of some predetermined length), and are sometimes called compression functions.  Information is lost in the output, so you can't map back from the hashbuckets to the keys. For every input, they calculate a hash code/hash value/hash, which should be a quick operation, such as adding up the numerical representations of characters in a hash key that is a string, or getting the numerical representation of the first character in hash keys that are strings.  Then, you take the modulus of the calculated hash value for the length of the array of hash buckets, to guarantee it will give an actual index of the array. Then you save the key's value to that array index/hash bucket.</li>
        <li>Hash Collisions are when a hash function outputs the same hash for two different keys, meaning you would be trying to save both key's values to the same hash bucket.</li>
        <ul>
            <li>First instead of just the value, we save the key-value pair, so that we know which value goes with which key in the hash bucket.</li>
            <li>This is often solved by separate chaining, which is making each hash bucket a linked list, and we append key/value pairs to the linked lists every time the hash function maps a key to that hash bucket.</li>
            <li>Open Addressing - linear probing is another method to deal with hash collisions, if the hash function tries to map a key-value pair to an hashbucket/array index that is already used, then there is a probing method that takes over to look for another index to save it at, such as checking if the next index is available, or if the fifth index away is available.  To find a key-value pair, you use the hash function and inspect that hashbucket, and if it doesn't contain the key/value pair, then you use the probing function to go to the next location it would be stored at, and so on.</li>
            <li>Clustering is when solving one hash collision ends up causing other hash collisions.  This happens with open addressing when a collision occurs and a key-value pair is stored in the next index number.  Then if another key comes along that should be stored there, it will need to get moved up to the next index.  This is lessened with non-linear probing methods like quadratic probing, where a colliding key is attempted to be stored 1 index away, then 4 away if not available, then 9 away if not available, then 16, etc.</li>
        </ul>
    </ul>
</body>
</html>