<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Structures</title>
</head>
<body>
    <a href="../index.html">Home</a>

    <h1>Data Structures</h1>

    <h2>Basics</h2>
    <ul>
        <li>The backbone of every piece of software is data and algorithms.</li>
        <li>Data structures are how data is stored and retrieved, including inputting,
            processing, maintaining, and retrieving data.  Their usefulness comes from 
            resembling the way data will be used.
        </li>
        <li>Picking a data structure depends on the intended purpose for the data,
            whether you need memory to be statically or dynamically allocated, and
            the speed at which the data structure can accomplish intended tasks.
        </li>
    </ul>

    <h2>Nodes</h2>
    <ul>
        <li>Nodes are the building block of many data structures</li>
        <li>A node is a piece of data (of any data type) and one or more links (called pointers) to other nodes. Pointers can be null, indicating the end of a path of nodes</li>
        <li>Orphaned nodes are nodes which no other node has a pointer to.  This means they can't
            be accessed and can happen if you mishandle adding, deleting, or modifying nodes.
        </li>
        <li>In javascript, nodes can be implemented using a class (example below) with a data property and a next property. The data can accept any data type, and the next property should only be allowed to be set to another instance of the node class.</li>
        <li>With this structure, you can do things like loop through nodes that are linked to one another by using their next property to set a variable in the loop to the next node
            <code><pre>
            class Node {
                constructor(data) {
                    this.data = data;
                    this.next = null;
                }

                setNextNode(node) {
                    if (!(node instanceof Node)) {
                    throw new Error('Next node must be a member of the Node class');
                    }
                    this.next = node;
                }

                getNextNode() {
                    return this.next;
                }
            }

            module.exports = Node;
        </pre></code></li>
    </ul>

    <h2>Linear Data Structures</h2>
    <h3>Singly Linked Lists</h3>
    <ul>
        <li>Singly Linked lists are a an ordered series of nodes that each link to a single other node.  The first node, which no other node links to, is the head node, and the last node, which has a null link, is the tail node. The linked list really is nothing more than a pointer to the head node. Singly linked lists can be thought of as having a direction.</li>
        <li>Common operations are adding a new node to the linked list by adding it to the beginning of the list, i.e. giving it a pointer to the current head node.  Also, you may need to remove a node in the middle of the linked list, which requires you to change the pointer of the node pointing to the removed node, to the node the removed node is pointing to.</li>
        <li>Many linked list problems require you to iterate through the linked list nodes, e.g. until
            a given data value is found.  For many problems, it is helpful to iterate through the linked list with two pointers simultaneously.  E.g. a pointer that moves through the list two nodes at a time, and one the moves through one at a time, which could allow you to find the middle of the list as once the double-speed pointer gets to the end of the list, the single-speed pointer will be in the middle of the list.  Or to get the nth-last item in the list, you have one pointer iterate through to the end of the list, while another pointer iterates through, n nodes behind the first pointer.
        </li>
        <li>The benefit of a linked list over an array is that it is faster to add things to it, whether to the beginning, end or middle of the list.  JS automatically allocates contiguous blocks of memory for an array, and when you add to it, it may need to reallocate memory somewhere else if there isn't memory available next to the current block.  This requires copying everything in the array to a new location.  Even if there is space available, if you want to insert into the middle of the array, then it needs to move everything over in memory after the location you insert to.  Likewise if you delete from the middle of the array then it has to move over everything in memory to fill in the deleted space.  Linked lists don't have to do any reallocation of memory, adding and inserting is always merely a matter of updating pointers.  On the other hand, arrays are beneficial becuase the support direct access, i.e. you can simply use an index number to access part of an array, whereas linked lists always require sequential access, i.e. you have to start at the head and follow the pointers until you get where you want.</li>
        <li>This can be implemented with a class in javascript, like this basic example below. Linked lists can have many other methods besides below that allows you to quickly do various things.
            <code><pre>
            const Node = require('./Node');

            class LinkedList {
                constructor() {
                    this.head = null;
                }

                addToHead(data) {
                    const newHead = new Node(data);
                    const currentHead = this.head;
                    this.head = newHead;
                    if (currentHead) {
                        this.head.setNextNode(currentHead);
                    }
                }

                addToTail(data) {
                    let tail = this.head;
                    if (!tail) {
                        this.head = new Node(data);
                    } else {
                        while (tail.getNextNode() !== null) {
                            tail = tail.getNextNode();
                        }
                        tail.setNextNode(new Node(data));
                    }
                }

                removeHead() {
                    const removedHead = this.head;
                    if (!removedHead) {
                        return;
                    }
                    this.head = removedHead.getNextNode();
                    return removedHead.data;
                }

                deleteWithValue(data) {
                    if (!this.head) {
                        return
                    }

                    if (this.head.data === data) {
                        this.head = this.head.getNextNode();
                        return;
                    }

                    let currentNode = this.head;

                    while(currentNode.getNextNode()) {
                        if(currentNode.getNextNode().data === data) {
                            currentNode.setNextNode(currentNode.getNextNode().getNextNode());
                            return;
                        }
                        currentNode = currentNode.getNextNode();
                    }
                }

                printList() {
                    let currentNode = this.head;
                    let output = '&lthead> ';
                    while (currentNode !== null) {
                        output += currentNode.data + ' ';
                        currentNode = currentNode.getNextNode();
                    }
                    output += '&lttail>';
                    console.log(output);
                }
            }

            module.exports = LinkedList;
        </pre></code></li>
    </ul>

    <h3>Doubly Linked Lists</h3>
    <ul>
        <li>A doubly linked list is an ordered series of nodes, each with a link to the next node in the list and the previous node in the list.  The first node is the head and has a null value for its pointer to the previous node, and the last node is the tail with a null value for its pointer to the next node. Unlike a singly linked list, the doubly linked list consists of a pointer to both the head node and the tail node.  An example of a double linked list is your browser history, where the first page you visit is the head, and subsequent pages are added to the tail, then you can traverse back and forward. Doubly linked lists can be though of as bi-directional.</li>
        <li>Operations like adding/removing the head/tail, or inserting/removing in the middle are more complicated than singly linked lists because you need to update both the previous and next pointers of each node.  However, it can be easier with tail operations since you have a pointer to the current tail to start at, instead of having to iterate through everything to find the tail.</li>
        <li>A circular linked list is one where the previous pointer of the head points to the tail, and the next pointer of the tail points to the head.</li>
        <li>An example implementation is below. The imported Node would be similar to above except it would have a previous property, and setPreviousNode and getPreviousNode methods.
            <code><pre>
            const Node = require('./Node');

            class DoublyLinkedList {
                constructor() {
                    this.head = null;
                    this.tail = null;
                }

                addToHead(data) {
                    const newHead = new Node(data);
                    const currentHead = this.head;
                    if (currentHead) {
                        currentHead.setPreviousNode(newHead);
                        newHead.setNextNode(currentHead);
                    }
                    this.head = newHead;
                    if (!this.tail) {
                        this.tail = newHead;
                    }
                }

                addToTail(data) {
                    const newTail = new Node(data);
                    const currentTail = this.tail;
                    if (currentTail) {
                        currentTail.setNextNode(newTail);
                        newTail.setPreviousNode(currentTail);
                    }
                    this.tail = newTail;
                    if (!this.head) {
                        this.head = newTail;
                    }
                }

                removeHead() {
                    const removedHead = this.head;
                    if (!removedHead) {
                        return;
                    }
                    this.head = removedHead.getNextNode();
                    if (this.head) {
                        this.head.setPreviousNode(null);
                    }
                    if (removedHead === this.tail) {
                        this.removeTail();
                    }
                    return removedHead.data;
                }

                removeTail() {
                    const removedTail = this.tail;
                    if (!removedTail) {
                        return;
                    }
                    this.tail = removedTail.getPreviousNode();
                    if (this.tail) {
                        this.tail.setNextNode(null);
                    }
                    if (removedTail === this.head) {
                        this.removeHead();
                    }
                    return removedTail.data;
                }

                removeByData(data) {
                    let nodeToRemove;
                    let currentNode = this.head;
                    while (currentNode !== null) {
                    if (currentNode.data === data) {
                        nodeToRemove = currentNode;
                        break;
                    }
                    currentNode = currentNode.getNextNode();
                    }
                    if (!nodeToRemove) {
                        return null;
                    }
                    if (nodeToRemove === this.head) {
                        this.removeHead();
                    } else if (nodeToRemove === this.tail) {
                        this.removeTail();
                    } else {
                        const nextNode = nodeToRemove.getNextNode();
                        const previousNode = nodeToRemove.getPreviousNode();
                        nextNode.setPreviousNode(previousNode);
                        previousNode.setNextNode(nextNode);
                    }
                    return nodeToRemove;
                }

                printList() {
                    let currentNode = this.head;
                    let output = '&lthead> ';
                    while (currentNode !== null) {
                        output += currentNode.data + ' ';
                        currentNode = currentNode.getNextNode();
                    }
                    output += '&lttail>';
                    console.log(output);
                }
            }

            module.exports = DoublyLinkedList;
        </pre></code></li>
    </ul>

    <h3>Queues</h3>
    <ul>
        <li>Queues are a series of nodes that only allows for adding to the tail (enqueue) and removing from the head (dequeue), as well as peek (reveal head without removing it). They can be implemented using various underlying data structures, but it is common to implement them as a linked list.  The linked list would store a reference to the head and tail, so that enqueue and dequeue can be done without traversal, and would not allow any methods of traversal or modification.</li>
        <li>Queues behave like people waiting in a line, where the front of the line is the head and the back is the tail.  They are a first-in first-out (FIFO) structure.</li>
        <li>Bounded queues have a limit to the number of nodes allowed.  Queue overflow occurs on a bounded queue if you try to enqueue past that limit.  Queue underflow can happen to bounded or non-bounded queues, and is when you try to dequeue from an empty queueu.</li>
        <li>Queues are used in breadth first search, job schedulers, print jobs, and recording and executing keyboard input.</li>
        <li>Example implementation:
            <code><pre>
            const LinkedList = require("./LinkedList");

            class Queue {
                constructor(maxSize = Infinity) {
                    this.queue = new LinkedList();
                    this.maxSize = maxSize;
                    this.size = 0;
                }

                isEmpty() {
                    return this.size === 0;
                }

                hasRoom() {
                    return this.size &lt this.maxSize;
                }

                enqueue(data) {
                    if (this.hasRoom()) {
                        this.queue.addToTail(data);
                        this.size++;
                    } else {
                        throw new Error("Queue is full!");
                    }
                }

                dequeue() {
                    if (!this.isEmpty()) {
                        const data = this.queue.removeHead();
                        this.size--;
                        return data;
                    } else {
                        throw new Error("Queue is empty!");
                    }
                }
            }

            module.exports = Queue;
        </pre></code></li>
    </ul>

    <h3>Stacks</h3>
    <ul>
        <li>Stacks are a series of nodes that only allows for adding to the head (push) and removing from the head (pop), as well as peek to look at head without removing.  They can be implemented using arrays and other data structures, but using a linked list is the most efficient way to do it.</li>
        <li>Stacks behave like a stack of book, with top of stack as the head and bottom of stack the tail, they are a Last-In First-Out (LIFO) structure</li>
        <li>Stacks can have a size limit, if you try to push onto a stack past its size limit it will cause stack overflow, and if you try to pop from an empty stack it will cause stack underflow</li>
        <li>They are used in browser forward/back buttons, or undo/redo list</li>
        <li>Here is an example implementation:
            <code><pre>
                const LinkedList = require('./LinkedList');

                class Stack {
                    constructor(maxSize = Infinity) {
                        this.stack = new LinkedList();
                        this.maxSize = maxSize;
                        this.size = 0;
                    }

                    hasRoom() {
                        return this.size &lt this.maxSize;
                    }
                    
                    isEmpty() {
                        return this.size === 0;
                    }

                    push(value) {
                        if (this.hasRoom()) {
                            this.stack.addToHead(value);
                            this.size++;
                        } else {
                            throw new Error('Stack is full');
                        }
                    }

                    pop() {
                        if (!this.isEmpty()) {
                            const value = this.stack.removeHead();
                            this.size--;
                            return value;
                        } else {
                            throw new Error('Stack is empty');
                        }
                    }

                    peek() {
                        if (!this.isEmpty()) {
                            return this.stack.head.data;
                        } else {
                            return null;
                        }
                    }
                }

                module.exports = Stack;
            </pre></code>
        </li>
    </ul>

    <h2>Complex Data Structures</h2>
    <h3>Hash Maps</h3>
    <ul>
        <li>A Hash Map is a way of storing unique key-value pairs (i.e. creating an associative array) using an array of a fixed length and a hashing function.  The hashing function maps each key-value pair to an array index (hash bucket) and is used to both save key-value pairs to hash-buckets, and later figure out which hash-buckets they are in to retrieve them.  For multiple key-value pairs mapped to the same array index, a collision strategy must be used.  Hash maps make for faster retrieval of a key's value than if they were all stored in a linked list and you had to iterate through all list nodes. It also allows for faster insertion/deletion time than if all the key value pairs were stored in an array and you had to constantly reallocate memory.</li>
        <li>A map, mathematically is synomous with function.  In computer science context, it means associating unique keys with a value.  Objects are often used to do this in javascript.</li>
        <li>Hashing or Hash Functions take a string or other data and return an integer.  They need to be deterministic, i.e. always give the same output for a given input, and should be a quick computation (e.g. get charCode of first letter of key, add charCodes together of letters in key).  Typically, they map a large input domain (all possible hash table keys) to a smaller output range (some range of integers called hash codes, hash values, or just hashes), and in this case may be called compression functions.  In this case, information is lost in the output, so you can't map back from range to the domain deterministically (irreversible).</li>
        </li>Compression: The hash function output may not necessarily be a valid index number in the array of hash buckets.  In that case, the hash values are mapped onto valid array indices (compression)often by using modulus.  The compression step may be done within the hash function, so that the hash function returns a hash that is already a valid array index.</li>
        <li>Hash Collisions are when a hash function outputs the same hash for two different keys, meaning you would be trying to save both key's values to the same hash bucket. A collision strategy is a way of dealing with this, and can involve using linked lists, more arrays, objects, js maps, and other methods</li>
        <ul>
            <li>First instead of just the value, we save the key-value pair, so that we know which value goes with which key in the hash bucket.</li>
            <li>This is often solved by separate chaining, which is making each hash bucket a linked list, and we append key/value pairs to the linked lists every time the hash function maps a key to that hash bucket.</li>
            <li>Open Addressing - linear probing is another method to deal with hash collisions, if the hash function tries to map a key-value pair to an hashbucket/array index that is already used, then there is a probing method that takes over to look for another index to save it at, such as checking if the next index is available, or if the fifth index away is available.  To find a key-value pair, you use the hash function and inspect that hashbucket, and if it doesn't contain the key/value pair, then you use the probing function to go to the next location it would be stored at, and so on.</li>
            <li>Clustering is when solving one hash collision ends up causing other hash collisions.  This happens with open addressing when a collision occurs and a key-value pair is stored in the next index number.  Then if another key comes along that should be stored there, it will need to get moved up to the next index.  This is lessened with non-linear probing methods like quadratic probing, where a colliding key is attempted to be stored 1 index away, then 4 away if not available, then 9 away if not available, then 16, etc.</li>
        </ul>
        <li>Example implementation: 
            <code><pre>
                const LinkedList = require('./LinkedList');
                const Node = require('./Node');
                class HashMap {
                constructor(size = 0) {
                    this.hashmap = new Array(size)
                        .fill(null)
                        .map(() => new LinkedList());
                }

                hash(key) {
                    let hashCode = 0;
                    for (let i = 0; i &lt key.length; i++) {
                        hashCode += hashCode + key.charCodeAt(i);
                    }
                    return hashCode % this.hashmap.length;
                }

                assign(key, value) {
                    const arrayIndex = this.hash(key);
                    const linkedList = this.hashmap[arrayIndex];
                    if (linkedList.head === null) {
                        linkedList.addToHead({ key, value });
                        return;
                    }
                    let current = linkedList.head;
                    while (current) {
                    if (current.data.key === key) {
                        current.data = { key, value };
                        break;
                    }
                    if (!current.next) {
                        current.next = new Node({ key, value });
                        break;
                    }
                    current = current.next;
                    }
                }

                retrieve(key) {
                    const arrayIndex = this.hash(key);
                    let current = this.hashmap[arrayIndex].head;
                    while(current) {
                        if(current.data.key === key) {
                            return current.data.value;
                        }
                        current = current.getNextNode();
                    }
                    return null;
                }
                }

                module.exports = HashMap;
            </pre></code>
        </li>
    </ul>

    <h3>Trees</h3>
    <ul>
        <li>Trees are used for heirachical data, like a file system.</li>
        <li>Trees are made of a kind of node called a tree node.  They have a data property and pointers to zero or more other tree nodes. In a tree, there is allowed to be only one pointer to each node.  Thus, every node has exactly one pointer to it, except for one.</li>
        <li>The root node is the node which no other nodes point to.  Leaf nodes are nodes that don't point to any other nodes.  The nodes that a given node points to are child nodes of that node.  The node that points to a given node is that node's parent.  Sibling nodes are nodes with the same parent.</li>
        <li>Depth refers to moving down the heirarchy from parent to child (height is the term used when moving up from children to parent).  Level 1 is the root node, it's children are level 2, their children are level 3, etc.  The more levels the deeper the tree.  Width refers to the number of children a parent has.  A tree can be described as deep (having many children that are also parents), wide (having many children per parent), or both.</li>
        <li>Depth-first traversal means sequencing the nodes in a tree, where the next node in the sequence is always the first child of the previous node, unless it has no children in which case the next node is its next sibling. Breadth-first traversal means sequencing the nodes in a tree where the next node in the sequence is the next sibling of the previous node, unless it has no next sibling in which case the next node is the first child of its earliest sibling.</li>
        <li>A binary tree is a tree where each parent has at most two children - the left child and right child.  A binary search tree is a binary tree where the left child is always less than the parent and the right child is always greater than the parent.</li>
        <li>Example implementation of a tree node.  A tree variable would simply be set equal to the root tree node:
            <code><pre>
                class TreeNode {
                    constructor(data) {
                        this.data = data;
                        this.children = [];
                    }

                    addChild(child) {
                        if (child instanceof TreeNode) {
                            this.children.push(child);
                        } else {
                            this.children.push(new TreeNode(child));
                        }
                    }
                    
                    removeChild(childToRemove) {
                        const length = this.children.length;
                        this.children = this.children.filter(child => {
                            return childToRemove instanceof TreeNode
                            ? child !== childToRemove
                            : child.data !== childToRemove;
                        });

                        if (length === this.children.length) {
                            this.children.forEach(child => child.removeChild(childToRemove));
                        }
                    }

                    print(level = 0) {
                        let result = '';
                        for (let i = 0; i &lt level; i++) {
                            result += '-- ';
                        }
                        console.log(`${result}${this.data}`);
                        this.children.forEach(child => child.print(level + 1));
                    }
                    
                    depthFirstTraversal() {
                        console.log(this.data);
                        this.children.forEach(child => child.depthFirstTraversal());
                    }
                    
                    breadthFirstTraversal() {
                        let queue = [ this ];
                        while (queue.length > 0) {
                            const current = queue.shift();
                        console.log(current.data);
                        queue = queue.concat(current.children);
                        }
                    }
                    };

                    module.exports = TreeNode;
            </pre></code>
        </li>
    </ul>

    <h3>Binary Search Trees</h3>
    <ul>
        <li>These are binary tree where every left child is less than the parent and every right child is greater than the parent.  Each node in the structure is itself a binary tree, and has data, a depth value, a left pointer, and a right pointer.  The dept value is 1 for the root, 2 for the root's children, 3 for the root's grandchildren, and so on.</li>
        <li>A Binary Tree would be set equal to an instance of the class below, each node inserted into it is also an instance of the class below.</li>
        <li>Example Implementation:
            <code><pre>
                class BinaryTree {
                    constructor(value, depth = 1) {
                        this.value = value;
                        this.depth = depth;
                        this.left = null;
                        this.right = null;
                    }

                    insert(value) {
                        if (value &lt this.value) {
                        if (!this.left) {
                            this.left = new BinaryTree(value, this.depth + 1);
                        } else {
                            this.left.insert(value);
                        }
                        } else {
                            if (!this.right) {
                                this.right = new BinaryTree(value, this.depth + 1);
                            } else {
                                this.right.insert(value);
                            }
                        }
                    }
                    
                    getNodeByValue(value) {
                        if (this.value === value) {
                            return this;
                        } else if ((this.left) && (value &lt this.value)) {
                            return this.left.getNodeByValue(value);
                        } else if (this.right) {
                            return this.right.getNodeByValue(value);
                        } else {
                            return null;
                        }
                    }

                    depthFirstTraversal() {
                        if (this.left) {
                            this.left.depthFirstTraversal();
                        }
                        console.log(`Depth=${this.depth}, Value=${this.value}`);
                        if (this.right) {
                            this.right.depthFirstTraversal();
                        }
                    }
                };
            </pre></code>
        </li>
    </ul>

    <h3>Heaps</h3>
    <ul>
        <li>Heaps are a type of binary tree, and are either a min-heap where every parent node is less than or equal to its children and thus the root is the minimum value, or a max-heap where every parent node is greater than or equal to its children and thus the root is the maximum value of the tree.  Often the root is the only node allowed to be removed. And new nodes are add to the next open child spot.</li>
        <li>Heaps can be used to implement priority queues, to find the shortest path (Dijkstraâ€™s Algorithm) and efficiently sorting data (heapsort)</li>
        <li>Heaps are often more efficiently implemented as a list instead of a tree of node objects, where the list can be mapped to a binary tree by filling in the tree from top to bottom, left to right.  This way the root of the tree has list index 0.  The root's left child is index 1, it's right child is index 2, the furthest left grandchild is index 3, and so on.  Each parent's left child has an index of (parentIndex*2)+1, and each their right child has an index of (parentIndex*2)+2.  Alternatively, if the root is index 1, then the left child will be parent*2 and the right child will be parent*2 + 1.  The left child is always even in this case, and thus parent = leftchild/2 = floor(leftchild/2) since leftchild is divisible by 2.  since floor(leftchild/2) = floor(leftchild/2 + 1/2) = floor((leftchild+1)/2) = floor(rightchild/2) we have parent = floor(leftchild/2) = floor(rightchild/2) or simply parent = floor(child/2). To recap, for root index = 1:</li>
        <ul>
            <li>leftchild = parent * 2<li>
            <li>rightchild = parent * 2 + 1<li>
            <li>parent = floor(child / 2)</li>
        </ul>
        <li>Heapifying is when you swap a parent and child that are out of order - e.g. for a min-heap when the child is smaller than the parent, you swap them.  When you add a new node to the bottom of heap you may need to heapify up (aka bubble up) by swapping the new node with its parent, and repeating this process until it is no longer greater than or less than its parent depending on if its a max or min heap.  When you remove a node, you first swap the node to remove with the last node in the heap, then remove it, then swap the swapped node with its smallest/largest child depending on if it is min/max heap to put it in order - this is to heapify down aka bubble down.</li>
        <li>If a heap of size 1 (the root only) is considered height 0, size 3 is height 1, size 7 is height 2, etc.  Then the max number of nodes at a given height is given by 2^0 + 2^1 + 2^2 + 2^3 + .... + 2^h = 2^(h+1) - 1.  This is a simple geometric series.</li>
        <li>Example implementation: 
        <code><pre>
            class MinHeap {
                constructor() {
                    this.heap = [null];
                    this.size = 0;
                }

                add(value) {
                    this.heap.push(value);
                    this.size++;
                    this.bubbleUp();
                }

                popMin() {
                    if (this.size === 0) {
                        return null 
                    }
                    const min = this.heap[1];
                    this.heap[1] = this.heap[this.size];
                    this.size--;
                    this.heap.pop();
                    this.heapify();
                    return min;
                }

                bubbleUp() {
                    let current = this.size;
                    while (current > 1 && this.heap[getParent(current)] > this.heap[current]) {
                        this.swap(current, getParent(current));
                        current = getParent(current);
                    }
                }

                heapify() {
                    let current = 1;
                    let leftChild = getLeft(current);
                    let rightChild = getRight(current);
                    // Check that there is something to swap (only need to check the left if both exist)
                    while (this.canSwap(current, leftChild, rightChild)){
                    // Only compare left & right if they both exist
                        if (this.exists(leftChild) && this.exists(rightChild)) {
                            // Make sure to swap with the smaller of the two children
                            if (this.heap[leftChild] &lt this.heap[rightChild]) {
                                this.swap(current, leftChild);
                                current = leftChild;
                            } else {
                                this.swap(current, rightChild);
                                current = rightChild;
                            }
                        } else {
                            // If only one child exist, always swap with the left
                            this.swap(current, leftChild);
                            current = leftChild;
                        }
                        leftChild = getLeft(current);
                        rightChild = getRight(current);
                    }
                }

                swap(a, b) {
                    [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];
                }

                exists(index) {
                    return index &lt= this.size;
                }

                canSwap(current, leftChild, rightChild) {
                    // Check that one of the possible swap conditions exists
                    return (
                    this.exists(leftChild) && this.heap[current] > this.heap[leftChild]
                    || this.exists(rightChild) && this.heap[current] > this.heap[rightChild]
                    );
                }
            }

            const getParent = current => Math.floor((current / 2));
            const getLeft = current => current * 2;
            const getRight = current => current * 2 + 1;

            module.exports = MinHeap;
        </pre></code></li>
    </ul>

    <h3>Graphs</h3>
    <ul>
        <li>Graphs are composed of nodes (aka vertices) connected by edges.</li>
        <li>Graphs are used to represent networks.  They can represent a bus map, with the vertices as bus stops and edges as bus routes between stops.  They can represent the internet, with web pages as vertices and hyperlinks between them as edges.</li>
        <li>Adjacent vertices are connected directly by a single edge.</li>
        <li>A path comprised the edges in a series of adjacent vertices</li>
        <li>A cycle or cyclical graph is when a path ends on the same vertex it started on</li>
        <li>Connectedness, the higher the ratio of edges to vertices, the more connected the graph is</li>
        <li>Disconnected graphs are graphs that have at least two vertices with no path between them</li>
        <li>Edges can be bidirectional or undirected (social network friends are friends with each other) or unidirectional or directed (one way street edges between intersection vertices).  These can be mixed in a single graph.</li>
        <li>Edges can also be weighted, where each edge has a numerical weight or cost associated with it, and the total weight or cost of a path is the sum of the edges in the path.  The edges in a visual representation of a graph won't necessarily all be scaled to the weight.  For example, weight could represent travel time between nodes, but the graph's edges visually might be scaled to distance between nodes. Weighted/unweighted edges can be mixed in a single graph.</li>
        <li>Adjacency Matrix, lists all vertices as rows in the matrix, and all vertices as columns in the matrix.  If a vertex in a row is adjacent to another vertex, then a "1" is put in the vertex's row under the column of the adjacent vertex.  Otherwise, a "0" is placed.  For weighted graphs, the edge's weight is placed instead of "1".</li>
        <li>Adjacency List, is a list of all the vertices, with the vertices they're adjacent too.  Could be an object with the keys being the vertices, and the values being arrays of the vertices adjacent to that key.</li>
        <li>Example Edge Implementation:
            <code><pre>
                class Edge {
                    constructor(start, end, weight = null) {
                        this.start = start;
                        this.end = end;
                        this.weight = weight;
                    }
                }

                module.exports = Edge;
            </pre></code>
        </li>
        <li>Example Vertex implementation:
            <code><pre>
                const Edge = require('./Edge.js');

                class Vertex {
                    constructor(data) {
                        this.data = data;
                        this.edges = [];
                    }

                    addEdge(vertex, weight) {
                        if (vertex instanceof Vertex) {
                            this.edges.push(new Edge(this, vertex, weight));
                        } else {
                            throw new Error('Edge start and end must both be Vertex');
                        }
                    }

                    removeEdge(vertex) {
                        this.edges = this.edges.filter(edge => edge.end !== vertex);
                    }

                    print() {
                        const edgeList = this.edges.map(edge =>
                            edge.weight !== null ? `${edge.end.data} (${edge.weight})` : edge.end.data);

                        const output = `${this.data} --> ${edgeList.join(', ')}`;
                        console.log(output);
                    }
                }

                module.exports = Vertex;
            </pre></code>
        </li>
        <li>Example Graph Implementation:
            <code><pre>
                const Edge = require('./Edge.js');
                const Vertex = require('./Vertex.js');

                class Graph {
                    constructor(isWeighted = false, isDirected = false) {
                        this.vertices = [];
                        this.isWeighted = isWeighted;
                        this.isDirected = isDirected;
                    }

                    addVertex(data) {
                        const newVertex = new Vertex(data);
                        this.vertices.push(newVertex);

                        return newVertex;
                    }

                    removeVertex(vertex) {
                        this.vertices = this.vertices.filter(v => v !== vertex);
                    }

                    addEdge(vertexOne, vertexTwo, weight) {
                        const edgeWeight = this.isWeighted ? weight : null;

                        if (vertexOne instanceof Vertex && vertexTwo instanceof Vertex) {
                            vertexOne.addEdge(vertexTwo, edgeWeight);

                            if (!this.isDirected) {
                                vertexTwo.addEdge(vertexOne, edgeWeight);
                            }
                        } else {
                            throw new Error('Expected Vertex arguments.');
                        }
                    }

                    removeEdge(vertexOne, vertexTwo) {
                        if (vertexOne instanceof Vertex && vertexTwo instanceof Vertex) {
                            vertexOne.removeEdge(vertexTwo);

                            if (!this.isDirected) {
                                vertexTwo.removeEdge(vertexOne);
                            }
                        } else {
                            throw new Error('Expected Vertex arguments.');
                        }
                    }

                    print() {
                        this.vertices.forEach(vertex => vertex.print());
                    }
                }

                module.exports = Graph;
            </pre></code>
        </li>
    </ul>
</body>
</html>