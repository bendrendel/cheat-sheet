<!DOCTYPE html>
<html>
    <head>
        <title>Web Basics</title>
    </head>
    <body>
        <a href="./index.html">Home</a>

        <h2>Basic Terms</h2>
        <ul>
            <li><strong>Front-end: </strong>Everything that runs in the browser environment - JS, HTML, CSS - has little to no access to the operating system/file system, also called client-side programming, composed of static assests such as JavaScript, CSS, HTML, images, and videos.  Different browsers provide slightly different environments, which can make programming tricky.</li>
            <li><strong>Back-end: </strong>Runs in a server environment with many different languages possible, full access to OS and filesystem.  Also called server-side programming, behind-the-scenes processes and data, enables dynamic websites that can e.g. pull data from a database for tailored displays depending on the user, could be simple if it is just a static website, or contain complex server-side programming for dynamic websites.</li>
            <li><strong>Stack: </strong>The collection of technologies used on the front and back end of a website, e.g. MEAN is MongoDB, Express, Angular, Node, LAMP is the archetypal stack Linux, Apace, MySQL, PHP</li>
            <li><strong>Authentication: </strong>Process of validating the identity of a user, e.g. username and password, securely stored on back-end and checked upon visiting, or may use external resources like Google credentials</li>
            <li><strong>Authorization: </strong>Controls which users have access to which resources and actions</li>
            <li><strong>Session/State Info: </strong>A mechanism that allows a server to store info on the current user of the site and send responses based on that.</li>
        </ul>
        <p><strong>Deploy: </strong>Making software or content accessible and available for use.  For web, software is made accessible of internet. Happens over and over during the course of a software project</p>
        <p><strong>Static Assets/Resources: </strong>Files that don't change could be html files, image files, javascript and other files.  After initially receiving a site's html, a client may send multiple other requests to get static assets like images and css files.</p>
        <p><strong>Dynamic Content: </strong>When the backend has logic deciding what assets to send based on the day or the user, etc</p>
        <p><strong>Static Website: </strong>A website where the same hard-coded content is sent from a server for every request.  The client sends an HTTP GET request to retrieve the resource at a specific path where the resource is located.  The server only ever has to handle GET requests, because there is no data to store, update or delete for the user.  Twitter for example is not static because it updates content as it changes</p>
        <p><strong>Dynamic Website: </strong>Returns different data for a URL based on information sent by the user, preferences, etc. Like getting data from a database and filling out an HTML template and then sendign that HTML to the client. The URL in the HTTP request to a dynamic website doesn't go to a specific file, rather it gets processed by the server, which generates the file dynamically to send back.</p>
        <p><strong>Single Page Web Application: </strong>A site that is just one html file that gets updated dynamically, pushes a lot of computational activity to the client instead of the server, makign for a more native-app like experience</p>
        <p><strong>Event-driven architecture: </strong>Traditional imperative programming executes a series of instructions in order, but for web applications, we need logic to handle things that could occur at different times (e.g. clickin a button), js and node.js use event-driven architecture</p>
        <p><strong>Simple Web Project Directory Structure: </strong>use lowercase folder and filenames with words separated by hyphens
            because casing and spaces will be interpreted differently in different situations, and google recognizes hyphens as a word separator</p>
        <pre class="code-pre ">d
            <code>
            project/
            ├── scripts/
            |   └── script.js
            ├── styles/
            |   └── style.css
            ├── images/
            |   └── image.jpg
            └── index.html
            </code>
        </pre>
        <p><strong>Web Browsers: </strong></p>
        <ul>
            <li><strong>Firefox</strong></li>
            <li><strong>Chrome</strong></li>
            <li><strong>Opera</strong></li>
            <li><strong>Safari</strong></li>
            <li><strong>Internet Explorer</strong> Old and incompatible with some modern web features.
                Very few people still use this so don't normally need to worry about it</li>
            <li><strong>Microsoft Edge</strong></li>
            <li><strong>Lynx</strong> Text-based terminal web browser good for seeing how visually-impaired will use site</li>
            <li><strong>Brave</strong></li>
        </ul>

        <h2>REST</h2>
        <p><strong>Representational State Transfer (REST): </strong>An architectural style for providing standards between computer systems on the web allwing easier communication between systems characterized by separation of client and server, and statelessness. systems following this are called REST-compliant or RESTful systems, communicate through a RESTful interface</p>
        <ul>
            <li><p><strong>Separation of Client and Server: </strong> needing only to know how to format message to each other, client and server can be implemented independently and code changed at any time without affecting the other, improves modularity, allows independent evolution, flexibility afforded by dedicated ui to work across different platforms, scalability by simplified server components, allows different clients to do the same actions to the same REST endpoints of a server and receive the same responses</p></li>
            <li><p><strong>Statelessness: </strong>the client and server do not need to know what state the other is in, and can understand any message independently without knowing previous messages.  enforced through, instead of commands, the use of resources through standardized operations that do not rely on implementation of interfaces, more reliable, faster, scalable, ability to componentize the system to allow for better management, updating, reusing, etc. </p></li>
        </ul>
        <p><strong>Client: </strong>In REST architecture, a client is the process interacting with the server, sending requests over the internet to retrieve or modify resources.  Could be a web browser requesting a website, could be another application, mobile device, smart appliance. AKA user-agent, any tool that acts on behalf of the user.</p>

        <h2>Servers and clients</h2>
        <p><strong>Server: </strong>Strictly speaking a server is a program or process, but it also often refers to hardware dedicated to running that program, which on a network is called a host. It provides (serves) functionality (services) to other programs or devices (users or clients) which use the services.  Servers can serve multiple clients and clients can access multiple servers.  In principle, a server is anything used or called by another process the client, but particularly refers to this when the server is remote.  Common servers are database servers, file servers that share folders/storage for networked computers, mail servers, print servers, web servers, game servers, and application servers that allow networked computers to run apps without installing them, catalog servers that maintain an index of whats on a large network like email addresses or name servers, computing servers which share RAM, CPU, or other resources with the network.  Most common today is a server following the request/response model where a server listens for incoming requests from clients and sends back responses. A given machine could run multiple servers and each server should have a unique port that traffic is routed to, but they all share the same IP address. every website has at least one web server and could have many thousands for huge sites like Facebook. Servers appear virtually as a single machine but in reality could be a collection of machines sharing the load, could be piecing together info from multiple other computers</p>
        <ul>
            <li><strong>Hardware/OS: </strong>Server-class hardware implies computers that are more powerful and reliable than personal computers to run server functionality that is constantly running, or meant to be part of a computing cluster of replaceable components, but any computer can be a server, e.g. if a laptop is sharing files on a local network it is a file server, and any capable computer on the internet can run a web server and thus be a host.  Servers need to have a dedicated IP address, which your ISP might not provide on your home computer.  Server hardware often lacks a GUI, mouse, keyboard, etc.  They often are mission-critical and always need to be on, so have continous uninterruptable power supplies, advanced cooling, hot-swappable components, and housed in dedicated buildings called data centers with special security, power, cooling, and internet connection infrastructure. Server farms or server clusters are a collection of servers that supply server functionality instead of just one machine. Most servers run Unix-like open source OS like those based on Linux and FreeBSD, but windows server also has a significant share. They often share the same base code these days as regular desktop OSs but are configured often without a GUI, special security features, detection of overheating, advanced networking capabalities, etc.</li>
            <li><strong>Static vs Dynamic: </strong>A static web server can only send hosted files as-is to the client.  A dynamic server consists of a static web server paired with a 'web application' - extra software often an application server and a database server or more.  The static web server determines if the request is for a static resource or a dynamic one.  If static it can just send back the resource, but if dynamic, then it sends the request to the web application to process the request and dynamically decide create something which is sent back to the web server to send back to the client.  The web application can for instance update a template html file before sending it to the client or maybe shoot off a registration email before sending a response, e.g. wikipedia has just a simple template page that is filled up with info from a database on a topic before sending to the client.</li>
            <li><strong>Scaling: </strong>Application scaling can be done horizontally meaning more machines are added to your pool of resources, or vertically meaning more power is added to an existing machine.  Web applications should almost always be scaled horizontally because this makes them more fault tolerant if any one machine goes down, allows different parts of the backend to be run on different machines, an because vertical scaling has a limit to how much one machine can do.</li>
            <li><strong>Load Balancer: </strong>Load balancers route incoming requests to your backend to different application servers, which are generally mirror images of each other, and then send the response from the app server back to the client.  Most web apps will have at least two application servers and often many more. This distributes the load across many servers.</li>
            <li><strong>Web Application Server: </strong>This is the core logic that handles a user's request and sends back a response, it may interact with a variety of backend infrastucture to do this like databases, caching layers, job queues, search services, microservices, logging, etc. It contols everything else.  These are written in many different languages with an MVC framework to go with.  Node/Express, Ruby/Rails, PHP/Laravel, Scala/Play, Java, C#, .Net, etc.</li>
            <li><strong>Database Server: </strong>Specialized server that the web application server communicates with for application data.  Two major types are relational SQL (e.g. MySQL, PostgreSQL, Oracle) and non-relational NoSQL(e.g. MongoDB, Redis, stores data in key-value pairs or a document storage model instead of tables). Other backend services may have their own databases that are isolated from the rest of the application</li>
            <li><strong>Caching Service: </strong>This caches results that are computationally expensive like fetching data from a database, into easy to retrieve key-value pairs that are perhaps O(1) run time.  e.g. google might cache search results for taylor swift because it so common, instead of rerunning the search each time.  Redis and memcache are techs that enable this</li>
            <li><strong>Job Servers: </strong>Also called workers, these servers perform tasks in a web apps job queue.  A job queue is a list of tasks a web app does asynchronously that isn't directly done to respond to a request.  E.g. google crawls the web to index search results behind the scenes, it doesn't do this in response to each request.  Or responding to a password reset request might be done through a job queue.  The job queue can be FIFO or priority queue, and the job servers are dedicated to checking the job queue and running whatever is at the front of the queue.</li>
            <li><strong>Full-text search: </strong>Many web apps offer a search feature, and this is often done through an independent service that computes an 'inverted index' of your site and takes any search requests and returns results.  An inverted index takes, e.g. all the image descriptions on your site, and creates a index of words with all the descriptions, with a pointer to each image that has that word in their description.</li>
            <li><strong>Services: </strong>At higher scales, applications will be broken into many services that run as separate applications. They aren't exposed to the external world but just run internally when needed.  e.g. an html to pdf service that accepts html and returns a pdf copy.</li>
            <li><strong>Business Analytics Data: </strong>User interaction event data is sent to a data 'firehose', which is processed and saved to cloud storage, and then loaded into a data warehouse for analysis like Oracle or AWS Redshift. There may also be a process to load operational database data into a data warehouse, e.g. actual site content, not just all the interaction data.</li>
            <li><strong>Cloud Storage: </strong>Instead of a local file system, files are often stored in cloud storage and accessed through an API HTTP request/response.  Amazon S3 is by far the most popular.</li>
            <li><strong>Content Delivery Network (CDN): </strong>This is a way of delivering static assets to the client like HTML, CSS, Javascript, images, videos, and any other static assets.  CDNs have many 'edge' servers around the world, so that a user can download the assets from the nearest edge server instead of the origin server.</li>
        </ul>
        <p><strong>Proxies: </strong>Between client and server there are numerous entities called proxies that perform different operations and act as gateways or caches. Could be filtering like antivirus load balancing allowing multiple servers to serve the requests, authentication, logging, content control. There are also many computers like routers, modems, and more</p>
        <p><strong>Request/Response Cycle: </strong>Communication between clients and servers in REST works one message at a time (instead of a stream of data) and requires clients to send a <em>request</em> to retrieve or modify resources and servers to then send a <em>response</em>. These days this is all in the HTTP Request and HTTP Response format. There is also the publish-subscribe pattern that is different than request response.  This is where a client uses request/response initially to subscribe to something on a server.  Then the publish-subscribe pattern is followed where the server pushes the service to the client without any further requests. Request-response is known as the client pulling data from a server, instead of publish-subscribe where the server pushes data to the client.  These client/server patterns are in contrast to a peer-to-peer model or some telephony services like Skype, but almost the whole internet is based on the client-server model with millions of servers worldwide. A single webpage may make the client send many requests to many servers, e.g. an image from one server, an ad from another, etc. This works as below:</p>
        <ul>
            <li><p>1. Client reads protocol of given URL</p></li>
            <li><p>2. Client reads domain name of given URL and gets its IP address from DNS</p></li>
            <li><p>3. Client opens TCP connection to the server at the IP address,
                    may reuse an existing connection or open several connections</p></li>
            <li><p>4. Client sends HTTP request</p></li>
            <li><p>5. Server receives request and sends response</p></li>
            <li><p>6. The response may prompt the client to make additional requests
                    to the same or other servers to get stylesheets, scripts, images, etc.</p></li>
            <li><p>7. TCP connection is closed</p></li>
        </ul>        
        <p><strong>Resource: </strong>Any entity on the web including HTML files, stylesheets, images, videos, and scripts, "nouns"/things of the web</p>
        <p><strong>MIME Types: </strong>Multipurpose Internet Mail Extensions, consist of a type and subtype separated by a slash</p>
        <ul>
            <li><code>text/html, text/css</code> text file containing html or css</li>
            <li><code>text/plain</code> generic text file, note this is not a super-type for text data, 
                i.e. text/plain is a separate type and not interchangeable with other text subtypes like text/html</li>
            <li><code>image/png, image/jpeg, image/gif</code> respective image types</li>
            <li><code>audio/wav, audio/mpeg</code> respective audio types</li>
            <li><code>video/mp4, video/ogg</code> respective video types</li>
            <li><code>application/json, application/pdf, application/xml, application/octet-stream</code> 
                respective application types</li>
        </ul>
        <p><strong>URL: </strong>Uniform Resource Locator</p>
        <p><strong>Network Protocol: </strong>Format of a request from a client to a server and resulting response, e.g. HTTP</p>
        <p><strong>TCP: </strong>Transmission Control Protocol, creates and manages the network channels between the client and server, used for many types of internet connections where one computer sends data to another</p>

        <h2>Domain Names</h2>
        <p>IP Address: This is what computers use to identify each other and communicate</p>
        <p>Domain Name: A human-friendly name that serve as aliases for the IP address of web hosting servers, often called a web address, also enables an email account, consists of a top level domain and second level domain</p>
        <ul>
            <li><p>Second Level Domain: to the left of the period in a domain name, e.g. mydomain in the the domain mydomain.com, should be short, memorable, easy to spell (avoid easily misspelled or confused things like hyphens, abbreviations, numbers)</p></li>
            <li><p>Top Level Domain (TLD): to the right of the period in the domain like .com, .org, .io, etc., all treated equally by google search</p></li>
        </ul>
        <p>Sub-domain: not part of the domain name but rather defined as a subdomain with a CNAME record, it is the "www" portion of the web address</p>
        <p>Protocol: also not part of the domain name, it is the "https" part of the web address </p>
        <p>Domain Name System (DNS): A global system that translates which domain names correspond to which servers IP address.  This is a backbone technology that makes the world wide web possible.</p>
        <p>when you type a domain name in your browser, it first checks it cache memory to see if it can pull the website from there,
            if not then it goes to the Resolver which is the internet service provider to see if it can find it,
            if not then it goes to the Root Server, there are only 13 in the world, and the root server instructs the resolver server on how to find the IP address
            now the resolver sends the domain to the TLD (Top Level Domain) Server which stores the address information for the top level domains and sends it back to the resolver server
            Now the resolver server sends it to the name server, which knows everything about the domain including the IP address, it sends it back to your computer which then stores it in its cache so it doesn't have to do this again when it wants the site
        </p>
        <p>Domain Name Registrar: Allows you to register domain names and create DNS records, e.g. Namecheap, Amazon Web Service's Route 53, creates unique name servers for the custom domain</p>
        <p>Hosted Zone: A group of DNS records for a single domain, needs an NS record that matches the name servers of the domain name which links it to the domain name, an A record that links the domain name (e.g. mydomain.com, the root domain) to the IP address of the host servers, and a CNAME record for www subdomain (e.g. www.mydomain.com) that links to the canoncial name</p>        
        <p>DNS Records: Globally accessible records that map domain names to servers</p>
        <ul>
            <li><p>A record (Address): A - IPv4 address, directs a domain name (e.g. mydomain.com) to an IP address of the servers hosting the site.  e.g. an A record for a GitHub hosted site should have two IP address values: 192.30.252.153 and 192.30.252.154</p></li>
            <li><p>CNAME record (Canonical Name): specifies a domain name to use as an alias for the true (canonical) domain name, conventially create a CNAME record with name "www" and value is canonical domain name (e.g. username.github.io), this will make www.mydomain.com a subdomain of the root domain, mydomain.com</p></li>
            <li>
                <p>NS record (Name Server): associates domain names with the correct DNS records, form of verification, when typing an address your browser first retrieves the name servers, then those are responsible for getting necessary DNS records</p>
                <p>e.g. in AWS Route 53, (handled automatically) the name servers have to be set on the registered domain name, and then that essentially links to a hosted zone with the same name servers, and the hosted zone has the additional necessary DNS records</p>
            </li>
        </ul>
    </body>
</html>