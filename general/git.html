<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Git</title>
        <link href="./styles.css" type="text/css" rel="stylesheet">
    </head>
    <body>
        <header>
            <a href="./index.html">Home</a>
        </header>
        <main>
            <h2>Git Terms</h2>
            <p><strong>Git: </strong>a piece of software that allows for tracking of changes, 
                industry-standard version control system for web development, must be installed on your computer,
                can be used to track changes to any project that is composed of text files arranged in directories</p>
            <p><strong>Git project: </strong>consists of three parts listed below</p>
            <ul>
                <li><p><strong>Working Directory: </strong>aka working tree, make changes to files - additions, deletions, modifications</p></li>
                <li><p><strong>Staging Area: </strong>list changes made to the working directory, files ready for commit</p></li>
                <li><p><strong>Repository: </strong>where Git permanently stores changes as sequential versions (aka commits) of the project</p></li>
            </ul>
            <p><strong>Git workflow: </strong>edit files in working directory, add files to staging area, save changes (commit) to repository</p>
            <p><strong>Git collobarative workflow: </strong>fetch and merge changes from remote, create new local branch to work on feature, develop feature on new branch making commits along way, when done fetch and merge from remote again, push project branch to remote for review</p>
            <p><strong>Github: </strong>simply a cloud storage service popularly used for backing up Git repositories, you copy (push) your local repository to Github periodically to back it up, GitHub automatically displays contents of README.txt if in your repository</p>
            <p><strong>HEAD: </strong>the commit you are currently on in the sequence of commits</p>
            <p><strong>branch: </strong>essentially when a copy of the repository is made at a given commit, then creating two independent branches of future commits</p>
            <p><strong>master branch: </strong>at any branching point, one branch is actually considered the master branch, so there is a continuous master branch back to the beginning</p>
            <p><strong>remote: </strong>a git repository outside your git project that multiple collaborators can work on and merge changes to, could be on the web, a network, or just somewhere else on your computer</p>
            
            <h2>Git Project Standard Files</h2>
            <p><strong>readme </strong>documentation of project, good idea in general to document your projects</p>
            <p><strong>.gitignore: </strong>this file can be included in the root folder of a git project's working directory to list all files and directories in 
                the working directory that git should ignore, simply list each file name or directory to ignore on its own line.
                All files and subdirectories in an ignored directory are ignored</p>
                <ul>
                    <li><stong>comments: </stong>comment a line by starting it with #</li>
                    <li><strong>.gitignore not in root: </strong>can create additional gitignore files in subdirectories,
                        which will take precedence over the .gitignore in the root directory</li>
                    <li><strong>directories: </strong>start directory names with / to only get directories in root folder, otherwise it will match
                        all directories with that name in subdirectories, e.g. /ignorethisdirectory</li>
                    <li>end directory names with / to only match directories, otherwise will match files that happen to
                        have the same name as the directory</li>
                    <li><strong>Wildcard: </strong>Use the * symbol as a wildcard, e.g. *.log will ignore all .log files</li>
                    <li><strong>Negation: </strong>Use the ! to negate patterns.  e.g. !audit.log in a subdirectory's .gitignore
                        file, will override the *.log in the root .gitignore file and make it so audit.log is not ignored</li>
                    <li><strong>git ls-files --others --ignored --exclude-standard </strong>run this in the root of a project to
                        get a list of all the files git is ignoring based on your .gitignore file(s)</li>
                </ul>
            <p><strong>license </strong></p>

            <h2>Basic Workflow Commands</h2>
            <p><strong>git init: </strong>turns the current working directory into a Git project</p>
                <ul>
                    <li>Can use git init in a local project directory that you've already worked on to start using version control</li>
                    <li>For a brand new project, helpful to use git init projectname to create a git project directory named projectname in the current directory</li>
                </ul>
            <p><strong>git config --global alias.sla 'log --oneline --decorate --graph --all'</strong> This will create an alias for a long command, in this case you alias the log command with options, to 'sla', (short log all), and this can then be run with simply 'git sla' in the command line</p>
            <p><strong>git status: </strong>check status of changes in working directory</p>
            <p><strong>git add filename: </strong>adds filename to the staging area, can list multiple filenames one after the other separated by a space or a single period adds all files in working directory (git add .)</p>
            <ul>
                <li><strong>git add -u . </strong> The -u option will look for all deleted files (files in HEAD but not in working directory) and stage them for deletion</li>
                <li><strong>git add -A . </strong>The -A option is for after you move files around in your working directory.  It will notice files that seem to have been deleted and new files
                    and recognize that the files are the same and were moved (this is true even if you made changes to the files as long as they are 50% similar judged by git's similarity index).
                    It will add these moves to the staging area.</li>
            </ul>
            <p><strong>git rm filename: </strong>deletes filename from staging area.  If filename has already been deleted from working directory,
                then this will delete it from staging area so the removal can then be committed.  If filename hasn't been deleted from working directory,
                then this command will delete it from the working directory and staging area</p>
                <ul>
                    <li><strong>git rm --cached filename</strong>deletes filename from staging area to be deleted in next commit,
                        but does not delete file from working directory (file in working directory will become untracked file)</li>
                </ul>
            <p><strong>git mv currentfile newfile </strong>moves file at currentfile (name of file with extension, may include a path) to newfile 
                (new path including name of file and extension) e.g. git mv myfile.jpg images/myfile.jpg, doesn't have to have same name of file.
                Technically this is a deletion and addition, and there is no behind the scenes tracking of the file as moved,
                instead this is detected after the fact when needed using a similarity index</p>
                <ul>
                    <li>This moves file in the working directory and staging area, to be committed</li>
                    <li>If you move a file in your working directory on your own without the mv command, 
                        then to make things right in your staging area, use git rm oldfile to remove the old file from the staging area
                        and git add newfile to add the new file to the staging area, which will cause git to recognize it as a moved file</li>
                </ul>
            <p><strong>git diff filename: </strong>for given filename, checks differences between working directory and staging area</p>
                <ul>
                    <li><strong>git diff </strong>leave off filename to see all differences for all files</li>
                    <li><strong>git diff --staged </strong>will show differences between files in staging area and HEAD commit</li>
                    <li><strong>git diff HEAD </strong>will show differences between working directory files and HEAD commit</li>
                    <li><strong>git diff --color-words </strong>add the --color-words to any diff command to see individual word changes on edited lines.
                        normally for an edited line git shows the original line being deleted and a new line being added</li>
                    <li><strong>git diff --word-diff </strong>similar to --color-words just slightly different format</li>
                    <li><strong>git diff --stat </strong>will only show filenames that have changes, won't show line by line changes</li>
                </ul>
            <p><strong>git commit -m "message": </strong>permanently stores changes in staging area to repository, 
                creates a "commit" with unique 40-character hexadecimal value SHA or git ref</p>
            <ul>
                <li>message should be in present tense and less than 50 characters, start with capitol letter</li>
                <li>Often will group changes to multiple files under a single commit, should craft commits to tell an easy to understand story of changes</li>
                <li>Can also make commits in a Github repo by editing a file directly in Github, when you save changes it creates a commit for the changes to that file</li>
                <li>can use git commit -am "message" to automatically git add all files and commit them in one command</li>
            </ul>
            <p><strong>git log: </strong>view chronological list of commits to repository, options below
                can be combined e.g. git log --patch --oneline</p>
            <ul>
                <li><strong>git log --oneline </strong>only shows shortened commit ref and message</li>
                <li><strong>git log --stat </strong>shows files involved in each commit</li>
                <li><strong>git log --patch </strong>shows the difference between each subsequent commit, like in diff command</li>
                <li><strong>git log --graph --all --decorate --oneline </strong>--graph shows a graph of all your commits and different branches
                    other options aren't necessary, just a recommended way to change how graph looks, very useful way to look at history</li>
                <li><strong>git log --pretty=format: '%C(yellow)%h%C(reset) - %an [%C(green)%ar%C(reset)] %s'</strong> %h is shortened commit hash, %an is author, %ar is relative date of commit, %s is short summary, %C sets a color and then resets a color basically wrapping something in that color.  This allows you to make your own format for the log. </li>
                <li><strong>git log -E -i --grep 'cach(e|ing)'</strong> This will search through your commit messages of everything in the history, for a regular expression, in this case it will find anything with cache or cahing in the history.  -E extended regular expressions for full searching power, -i case insensitive</li>
                <li><strong>git log -S with_active_subscription </strong>-S searches the actual code in each commit for any changes that involve the provided string.  In this case it will show any commit that changes the number of occurances of the provided string with_active_subscription, great if you have code you need to find</li>
                <li><strong>git log --oneline -- MyFile.txt</strong> Will show all changes to just the provided file MyFile.txt.  This example includes the --oneline option which is mandatory, and use -- with a space after the option, which is needed to separate options from arguments, you could also just run git log MyFile.txt if you don't want oneline.</li>
                <li><strong>git blame MyFile.txt</strong> gives you the name of who changed each line in the file.</li>
                <li><strong>git log --stat -- filename </strong>shows all commits that contain changes to the given filename, which should include extension
                    and may contain a filepath e.g. git log --stat -- images/myimg.jpg</li>
                    <ul>
                        <li><strong>git log --stat -M --follow -- filename </strong>use this version to follow the given filename across moves,
                            showing commits for earlier file location, defaults to a 50% similarity index to follow files, can include different
                            threshold after the -M if desired, e.g. -M75</li>
                    </ul>
            </ul>
            <p><strong>git stash: </strong>This stores unstaged changes in a special 'stash'.  Good if you're not ready to make a commit, but you need to leave the branch you're on and go work on something else.</p>
            <ul>
                <li><strong>git stash -u: </strong>The -u mean include untracked files and its best to use stash with this option to save your stash.  It will include both changes to existing files and any brand new files that you haven't started tracking yet.</li>
                <li><strong>git stash pop: </strong>This will restore the saved stash back to your working directory</li>
                <li><strong>git stash drop: </strong>This will delete the saved stash</li>

            </ul>

            <h2>Backtracking Commands</h2>
            <p><strong>git show HEAD: </strong>shows log info and all committed changes for the HEAD commit, or any commit hash you give it</p>
            <p><strong>git reflog: </strong>the reflog provides 30 days of all history on a branch, both forward commits and backward
                resets, deletions of branches, and rebases</p>
                <ul>

                    <li><strong>gitk --all `git reflog | cut -c1-7`& </strong>use this comman to open a GUI showing the reflog so you can 
                        better see the organization of the reflog, which branches are out on their own, what commits are no longer part of it</li>
                    <li><strong>git reflog show branch-name</strong> shows the full reflog history for the given branch-name only</li>
                </ul>

            <h3>Reset</h3>
            <p><strong>git reset --soft SHA: </strong>Moves the head to the given SHA (first 7 characters) and stops there.  Does not change the staging area or working directory.  Instead of a SHA, you could use HEAD~ to move to the parent of the HEAD (i.e. one commit back from where HEAD currently is) or HEAD~2 to move two parents back or any other number of parents back.  This can be useful because you can then make a new commit from the unchanged files in the staging area.  You could move back one commit to essentially redo your most recent commit, or you could move back multiple commits to essentially squash multiple commits into one commit.</p>     
            <p><strong>git reset --mixed SHA: </strong>Moves the head to the given SHA (first 7 chars, or use HEAD/HEAD~/HEAD~2/etc shorthand) and then updates the staging area to the files in that commit.  --mixed is the default so it can also be omitted and git reset SHA will assume --mixed. Using it with HEAD is useful when you want to "unstage" files in the staging area because it will set them back to the version in HEAD, but leave the working directory untouched.  If you specify a particular file name as in git reset --mixed SHA file.txt, then the first step of moving the head is skipped, but the second step of copying the file from the given SHA into the staging directory is still performed.  If used with HEAD for the SHA, then this is useful to "unstage" a single file.</p>
            <p><strong>git reset --hard SHA: </strong>Moves the head to the given SHA (first 7 chars, or use HEAD~/HEAD~2/etc shorthand) and then updates the staging area and working directory to the files in that commit.  This is potentially dangerous if the files in the working directory have not been saved to a commit.  If they have, then you could get them back using reflog.  If they haven't then they will be permanently lost.</p>

            <h3>Checkout</h3>
            <p><strong>git checkout HEAD filename: </strong>replace filename in working directory with version of filename in HEAD commit, can use . to replace all files</p>
            <p><strong>git checkout SHA filename: </strong>can also use a SHA (or first 7 characters of one) to replace the given filename in the working directory with the version of that file from the given SHA.  leave out filename to set entire working tree to the given SHA, this is intended to explore files/folders at the given commit and you shoudln't make commits while here</p>            
            <p><strong>git checkout -- filename: </strong>replaces filename in working directory with version of file in most recent commit</p>


            <h2>Branching Commands</h2>
            <p><strong>git branch: </strong>shows all branches with a * next to the branch you are on, 
                the master branch should always be production-ready, so always do your work on a separate branch</p>
            <p><strong>git branch new_branch: </strong>creates a new branch with name new_branch, name should describe purpose of branch in a word or two, no whitespace
                e.g. refactor-authentication or user-content-cache-key</p>
                <ul>
                    <li><strong>git checkout -b newbranch </strong>this will create a new branch and also checkout to it right away</li>
                </ul>
            <p><strong>git checkout branch_name: </strong>switches you over to the branch with name branch_name</p>
                <ul>
                    <li>This updates your staging area and working directory with that branch's files, and future commits will be to that branch.  The command will check for any changes to your working directory before switching to ensure it doesn't overwrite any unsaved changes in the working directory.</li>
                </ul>
            <p><strong>git branch -d branch_name: </strong>deletes branch with branch_name, should be done once a branch has been merged into a receiver branch like master
                because the receiver will have all the commits from the branch in it after merging, can't delete the branch you're on, so switch to a different branch first</p>
                <ul>
                    <li><strong>git branch -D branchname: </strong>If a branch is not fully merged onto master, then -d won't let you delete it, use -D to do so</li>
                </ul>
            <p><strong>git rebase branchname: </strong>Adds new commits from branchname to the current checked out branch, where branchname is the branch that the currently
                checked out branch was branched off of.  This pulls in any new commits since you branched off of branchname, to make it look like you started your branch from
                the current version of branchname</p>
                <ul>
                    <li>This takes the current version of branchname, and "replays" the commits in your checked out branch starting from the latest commit of branchname</li>
                    <li>This changes the SHAs on all of the commits you've made in your checked out branch, so be careful if others are working on this branch as well
                        as it could mess them up</li>
                    <li>Rebase is good if clarity of history on the master branch is desired, because it creates an easy to follow linear history on the master
                        branch.  However, for projects where speed of delivery is more important, rebase may not be preferred, and instead merge will be used
                    </li>
                </ul>

            <h2>Merging Commands</h2>
            <p><strong>git merge branch_name: </strong>brings all commits from branch_name (giver branch) into the current branch (receiver branch)</p>
            <ul>
                <li>typically you checkout the master branch, then run this command to merge branch_name into master</li>
                <li>git merge branch_name --no-ff, this command will prevent git from doing a fast forward merge if one is possible.  a fast-forward merge is when e.g. the last commit on the master branch is the ancestor of the feature branch you are merging, and thus the feature branch commits can just be added directly onto the end of the master branch.  When you use no-ff, this will create a single merge commit that is put on the end of the master branch, which will contain all the changes made in the feature.  However, this commit will have two parents, one is the previous commit on master, and the other is the last commit on feature.  Basically the feature commits are collapsed into one commit that is added to the master branch, but the whole history of the feautre branch commits is preserved but shown as being from a different branch.  this command will open vim and ask for a commit message for the merge, to exit vim, press the escape key, then a colon, then wq and press enter to exit vim.  some teams use no-ff and other don't, no-ff is convenient in that it creates a consolidated commit to see all changes from the features branch.</li>
            </ul>
            <p><strong>Resolving merge conflicts: </strong></p>
            <ul>
                <li>any line of a file with conflicting changes between the branches will show an error msg, and the file will not be committed
                    and a special version of the file in the working directory will show the two conflicting alternatives for the line</li>
                <li>The receiver branch version of the line(s) will be between &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD and ======= 
                    while the giver branch version will be between the ======= and &gt;&gt;&gt;&gt;&gt;&gt;&gt; branchname</li>
                <li>to resolve, delete all of the special markup added by Git and keep only the version of the line you want or otherwise edit</li>
                <li>now you should stage the file, fix and stage any other conflicting files, and finally make a commit 
                    with the message "Resolve merge conflict" or similar</li>
            </ul>
            <p><strong>git merge --abort: </strong>After merging, if there are merge conflicts you don't want to deal with right now,
                then you can run this command to abort the merge, and it will return the working directory and staging area back to
                the last commit of the receiver branch</p>
            <p><strong>git merge --squash branchname: </strong>The --squash option will show the merge as a single commit on the receiver branch
                instead of adding all of the commits from the giver branch</p>
        
            <h2>Remote Commands</h2>
            <p><strong>creating a github repository: </strong>get started with a remote on github by creating an empty repository on github, which will provide instructions for adding it as a remote for a local project, the local project should have at least one commit so there is something to push</p>
                <ul>
                    <li><p>Github will give you option to create a readme, .gitignore, etc.  if you do, it will create an initial commit with these files added.
                        However, don't do this if you already have a local repository with commits to push to this github repository, as this will cause merge problems.  You just want an empty repo on github to push your local project to.</p></li>
                </ul>
            <p><strong>git clone remote_location clone_name: </strong>good for branching, creates a copy of the git repository at remote_location (web address or filepath). the copy is named clone_name and placed in the current working directory, 
                the remote will be aliased origin.  Useful when there is a repo on github that you want a local copy of to work in.  You can use git clone remote_location, to create a local copy of the repo at remote_location and it will have the same name as the remote repo.
                Then you might make a local branch, do your work and commit things, then push the branch back to the repo, where it can be reviewed, you can make a pull request, it can be merged eventually to master</p>
            <p><strong>git remote add origin remote_location: </strong>good for initial set up, run from local project directory to add a remote repository at remote_location (e.g. a github repository web url),
                remote will have alias origin in this example (common) but could be named something else</p>
            <p><strong>git remote set-url origin remote_location: </strong>allows you to change the url of a remote (origin in this example) to a different remote_location</p>
            <p><strong>git remote rm origin: </strong>run from local project directory, removes remote repository named origin</p>
            <p><strong>git remote -v: </strong>lists remotes for current working directory if directory is a git project, good to confirm remotes were added successfully</p>
            <p><strong>git branch -r: </strong>lists remote branches, remote branches named the same as local branches except start with the remote name, e.g. origin/master, origin/feature</p>
            <p><strong>git fetch origin: </strong>brings changes in from a remote, and puts them in your remote branches like origin/master, origin/feature, etc.
                the remote branches can then be merged to your local branch by checking out the local branch and then using git merge origin/master or git merge origin/feature,
                or whatever the name of the branch is you are merging</p>
            <p><strong>git pull origin: </strong>same as fetch but also will merge the corresponding remote branch into whatever local branch you have checked out.  Use simply git pull
                to pull in all remote trackign branches including the one you have checked out.  This is good if you want to get a new branch someone else made to work on.
                Another example, you may be on the master branch, and
                perhaps someone on your team has pushed commits to the master branch, so that your local master 
                branch is outdated.  And in the meantime, you have made commits yourself on your local copy of master.
                If you try to push to github, you will get an error message saying the remote contains changes 
                that you do not have locally.  This means you need to pull in those changes from the remote.<br>

                Well, you can run <code>git pull origin master</code> This will attempt a merge, and you will
                see the merge screen if there are no conflicts.  On the merge screen, press ESC, and then :wq and ENTER to
                exit the merge screen. If there are no conflicts, then the merge will happen without incident and successfully merge the commits from you and your teammate into your local master branch.  Then you can
                push your master branch to github with the successfully merged commits. <br>
                
                However, if you pull from the remote and there are conflicting changes in your commit and your teammates
                commits, then git cannot automatically merge the commits and you'll  get a warning message,
                and git will automatically add the merge labelling to any of the files in your working directory
                that are in conflict with the files in the remote.  This is when you should edit the working directory
                file to delete the merge conflict labelling and just keep the version you want.  Now you can add 
                your edited files to the staging area, commit them with a message like "resolve merge conflict",
                and now you can push them to the remote. <br>

                To avoid merge conflicts as much as possibe, run git pulls frequently to always get the latest changes
                from the remote for whatever branch you're working on. <br>

                If you are working on a feature branch off of master, then likewise, you should pull the master branch
                every couple or days at least, and while the feature branch is checked out you should merge master into
                your feature branch.  That way you keep your feature branch up to date so that when you finally do merge
                it back into master, you won't have a ton of conflicts to deal with.
            </p>
            <p><strong>git push origin your_branch_name: </strong>copies the local your_branch_name branch to the corresponding remote origin branch,
                can leave off your_branch_name to simply copy the branch you have checked out.  However, you must include your_branch_name if you are pushing it up to origin and you haven't set up remote tracking for the branch.
                If the branch is new on your local repo and doesn't exist in the remote repo, then you'll probably want to set up the branch remotely,
                to do this, on your first push of the new branch use git push --set-upstream origin my-branch
                Often used to copy a local feature branch to the remote repository named origin, so someone can review your branch and merge it to origin/master</p>
            <p><strong>Forking: </strong>To contribute to an open project on Github, you should use the fork feature in that project's repository
                to create a copy of the repository in your own Github account.  This allows you to safely work on the project on your own.
                Commonly you will fork the project, then clone the project onto your machine to get a local copy, then make a feature branch,
                commit changes to the feature branch, then push the feature branch up to the remote using --set-upstream since it is a new branch,
                then you would submit a pull request for the branch in your forked repo, with description, etc. and this would push the pull request up to the original repo for review.</p>
            <p><strong>Pull request: </strong>Within Github, when you are working on a branch of a repository, whether you're a core contributor
                with ability to push to the repository or you forked the project and worked on a branch on your own, you should make a pull request
                for the branch when its ready for review.  With a fork this is requesting from the owner to review your branch and is the route for getting your branch merged into the main branch of the original repository.  With a repository that you have contribution rights to you could merge your branch directly but a pull request gives the whole team a chance to review it first.  Pull requests
                have feedback functionality built in and code testing abilities built in. You can keep making commits to your branch in response to feedback in the pull request. When finished, it may be first deployed to a test environment, or it could be deployed directly to the production environment.  If there are no issues, it can then be merged into the master branch
                and then delete your branch to keep your repo clean with no unneccessary branches, as your commits and the pull request discussion become part of the destination branch.  You can open a pull request at any time during your development, maybe if you
                want some feedback on the code you are working on. Pull requests can be requesting to merge
                any branch into any other branch (not just master), and you select these two branches
                when creating the pull request and the differences between these two branches are shown in
                the pull request.</p>

            <h2>Github Workflow</h2>
            <ol>
                <li><strong>Branch: </strong>Create a branch off the <code>master</code> branch to work on a feature or fix.
                    Anything on the <code>master</code> branch should be deployable</li>
                <li><strong>Commit: </strong>Work on the new branch and make commits as you go, commit often!</li>
                <li><strong>Pull: </strong>Open a pull request to share what you have so far, get feedback or advice, or when you're ready for review
                    Use @mention system in Github to request feedback from specific people or teams
                    Good for contributing to open source projects or any project to allow review before merging to main branch</li>
                <li><strong>Review: </strong>Review pull request comments (written in markdown) and push additional commits to your branch if needed
                    to address comments.  Reviewers can see your additional commits and provide more comments</li>
                <li><strong>Deploy: </strong>Depending on team, deploy your branch to testing environment or directly to production
                    If there are problems, you can roll back by deploying the main branch</li>
                <li><strong>Merge: </strong>Now you can merge your code to the main branch.  Pull requests preserve a record of changes to your code
                    You can incorporate keywords into pull requests so that when it merges it closes an issue you fixed with the branch,
                    e.g. "Closes #32" will close issue 32 when merged into main</li>
            </ol>
            <ul>
                <li><strong>Issues: </strong>Github issues can be used for a variety of things but often used as a bug-tracker for a project, usually with a title and description,
                    and assignee in charge of the issue, color coded labels to help organize issues (e.g. could be the type of coding like js, css, or if it is a feature or bug,
                    or if it is confirmed or not, etc.), comments from anyone with access to the repo,
                    and milestones which are containers for a collection of issues (e.g. beta version could be a milestone with many issues in it to solve first,
                    october sprint coudl be a milestone with many issues, redesign could be a milestone, etc.).  They often contain @mentions to tag people,
                    and references to other issues and commits to tie related things together.</li>
                <li><strong>Notifications: </strong>Github can email you notifications and/or leave them for you on github under notifications, for repos you are watching (notify
                    about changes, issues etc), or for repos you are participating in (everytime somone @mentions you)</li>
                <li><strong>@mentions: </strong>common to tag people with the 'cc' convention for carbon copy. e.g. in body of issue at end of comment you put /cc @person1 @person2</li>
                <li><strong>references: </strong>reference other issues in the same repo by simply including #42 in the issue body, or whatever number the issue is that you reference,
                    or reference issues in other repos using username/projectname#42.  If you make a commit that starts with Fixes, Fix, Fixed, Close, Closed, or Closes and include the
                    issue number in the commit message, then it will autamotically close the issue when you commit.</li>
                <li><strong>Wikis</strong> For more detailed info on the project besides what a Readme provides, you can make a wiki for a project, supports markdown. this is all done on
                    github's website under your project, has a home page as the entrance to the wiki and can have many other pages, and sidebard navigation.</li>
            </ul>

        </main>
    </body>
</html>