<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Git</title>
        <link href="./styles.css" type="text/css" rel="stylesheet">
    </head>
    <body>
        <header>
            <a href="./index.html">Home</a>
        </header>
        <main>
            <h2>Git Terms</h2>
            <p><strong>Git: </strong>a piece of software that allows for tracking of changes, 
                industry-standard version control system for web development, must be installed on your computer,
                can be used to track changes to any project that is composed of text files arranged in directories</p>
            <p><strong>Git project: </strong>consists of three parts listed below</p>
            <ul>
                <li><p><strong>Working Directory: </strong>aka working tree, make changes to files - additions, deletions, modifications</p></li>
                <li><p><strong>Staging Area: </strong>list changes made to the working directory, files ready for commit</p></li>
                <li><p><strong>Repository: </strong>where Git permanently stores changes as sequential versions (aka commits) of the project</p></li>
            </ul>
            <p><strong>Git workflow: </strong>edit files in working directory, add files to staging area, save changes (commit) to repository</p>
            <p><strong>Git collobarative workflow: </strong>fetch and merge changes from remote, create new local branch to work on feature, develop feature on new branch making commits along way, when done fetch and merge from remote again, push project branch to remote for review</p>
            <p><strong>Github: </strong>simply a cloud storage service popularly used for backing up Git repositories, you copy (push) your local repository to Github periodically to back it up, GitHub automatically displays contents of README.txt if in your repository</p>
            <p><strong>HEAD: </strong>the commit you are currently on in the sequence of commits</p>
            <p><strong>branch: </strong>essentially when a copy of the repository is made at a given commit, then creating two independent branches of future commits</p>
            <p><strong>master branch: </strong>at any branching point, one branch is actually considered the master branch, so there is a continuous master branch back to the beginning</p>
            <p><strong>remote: </strong>a git repository outside your git project that multiple collaborators can work on and merge changes to, could be on the web, a network, or just somewhere else on your computer</p>
            
            <h2>Git Project Standard Files</h2>
            <p><strong>readme </strong>documentation of project, good idea in general to document your projects</p>
            <p><strong>.gitignore: </strong>this file can be included in the root folder of a git project's working directory to list all files and directories in 
                the working directory that git should ignore, simply list each file name or directory to ignore on its own line.
                All files and subdirectories in an ignored directory are ignored</p>
                <ul>
                    <li><stong>comments: </stong>comment a line by starting it with #</li>
                    <li><strong>.gitignore not in root: </strong>can create additional gitignore files in subdirectories,
                        which will take precedence over the .gitignore in the root directory</li>
                    <li><strong>directories: </strong>start directory names with / to only get directories in root folder, otherwise it will match
                        all directories with that name in subdirectories, e.g. /ignorethisdirectory</li>
                    <li>end directory names with / to only match directories, otherwise will match files that happen to
                        have the same name as the directory</li>
                    <li><strong>Wildcard: </strong>Use the * symbol as a wildcard, e.g. *.log will ignore all .log files</li>
                    <li><strong>Negation: </strong>Use the ! to negate patterns.  e.g. !audit.log in a subdirectory's .gitignore
                        file, will override the *.log in the root .gitignore file and make it so audit.log is not ignored</li>
                    <li><strong>git ls-files --others --ignored --exclude-standard </strong>run this in the root of a project to
                        get a list of all the files git is ignoring based on your .gitignore file(s)</li>
                </ul>
            <p><strong>license </strong></p>

            <h2>Basic Workflow Commands</h2>
            <p><strong>git init: </strong>turns the current working directory into a Git project</p>
                <ul>
                    <li>Can use git init in a local project directory that you've already worked on to start using version control</li>
                    <li>For a brand new project, helpful to use git init projectname to create a git project directory named projectname in the current directory</li>
                </ul>
            <p><strong>git status: </strong>check status of changes in working directory</p>
            <p><strong>git add filename: </strong>adds filename to the staging area, can list multiple filenames one after the other separated by a space or a single period adds all files in working directory (git add .)</p>
            <ul>
                <li><strong>git add -u . </strong> The -u option will look for all deleted files (files in HEAD but not in working directory) and stage them for deletion</li>
                <li><strong>git add -A . </strong>The -A option is for after you move files around in your working directory.  It will notice files that seem to have been deleted and new files
                    and recognize that the files are the same and were moved (this is true even if you made changes to the files as long as they are 50% similar judged by git's similarity index).
                    It will add these moves to the staging area.</li>
            </ul>
            <p><strong>git rm filename: </strong>deletes filename from staging area.  If filename has already been deleted from working directory,
                then this will delete it from staging area so the removal can then be committed.  If filename hasn't been deleted from working directory,
                then this command will delete it from the working directory and staging area</p>
                <ul>
                    <li><strong>git rm --cached filename</strong>deletes filename from staging area to be deleted in next commit,
                        but does not delete file from working directory (file in working directory will become untracked file)</li>
                </ul>
            <p><strong>git mv currentfile newfile </strong>moves file at currentfile (name of file with extension, may include a path) to newfile 
                (new path including name of file and extension) e.g. git mv myfile.jpg images/myfile.jpg, doesn't have to have same name of file.
                Technically this is a deletion and addition, and there is no behind the scenes tracking of the file as moved,
                instead this is detected after the fact when needed using a similarity index</p>
                <ul>
                    <li>This moves file in the working directory and staging area, to be committed</li>
                    <li>If you move a file in your working directory on your own without the mv command, 
                        then to make things right in your staging area, use git rm oldfile to remove the old file from the staging area
                        and git add newfile to add the new file to the staging area, which will cause git to recognize it as a moved file</li>
                </ul>
            <p><strong>git diff filename: </strong>for given filename, checks differences between working directory and staging area</p>
                <ul>
                    <li><strong>git diff </strong>leave off filename to see all differences for all files</li>
                    <li><strong>git diff --staged </strong>will show differences between files in staging area and HEAD commit</li>
                    <li><strong>git diff HEAD </strong>will show differences between working directory files and HEAD commit</li>
                    <li><strong>git diff --color-words </strong>add the --color-words to any diff command to see individual word changes on edited lines.
                        normally for an edited line git shows the original line being deleted and a new line being added</li>
                    <li><strong>git diff --word-diff </strong>similar to --color-words just slightly different format</li>
                    <li><strong>git diff --stat </strong>will only show filenames that have changes, won't show line by line changes</li>
                </ul>
            <p><strong>git commit -m "message": </strong>permanently stores changes in staging area to repository, 
                creates a "commit" with unique 40-character hexadecimal value SHA or git ref</p>
            <ul>
                <li>message should be in present tense and less than 50 characters, start with capitol letter</li>
                <li>Often will group changes to multiple files under a single commit, should craft commits to tell an easy to understand story of changes</li>
                <li>Can also make commits in a Github repo by editing a file directly in Github, when you save changes it creates a commit for the changes to that file</li>
                <li>can use git commit -am "message" to automatically git add all files and commit them in one command</li>
            </ul>
            <p><strong>git log: </strong>view chronological list of commits to repository, options below
                can be combined e.g. git log --patch --oneline</p>
            <ul>
                <li><strong>git log --oneline </strong>only shows shortened commit ref and message</li>
                <li><strong>git log --stat </strong>shows files involved in each commit</li>
                <li><strong>git log --patch </strong>shows the difference between each subsequent commit, like in diff command</li>
                <li><strong>git log --graph --all --decorate --oneline </strong>--graph shows a graph of all your commits and different branches
                    other options aren't necessary, just a recommended way to change how graph looks</li>
                <li><strong>git log --stat -- filename </strong>shows all commits that contain changes to the given filename, which should include extension
                    and may contain a filepath e.g. git log --stat -- images/myimg.jpg</li>
                    <ul>
                        <li><strong>git log --stat -M --follow -- filename </strong>use this version to follow the given filename across moves,
                            showing commits for earlier file location, defaults to a 50% similarity index to follow files, can include different
                            threshold after the -M if desired, e.g. -M75</li>
                    </ul>
            </ul>

            <h2>Backtracking Commands</h2>
            <p><strong>git show HEAD: </strong>shows log info and all committed changes for the HEAD commit</p>
            
            <h3>Reset</h3>
            <p><strong>git reset --soft SHA: </strong>Moves the head to the given SHA (first 7 characters) and stops there.  Does not change the staging area or working directory.  Instead of a SHA, you could use HEAD~ to move to the parent of the HEAD (i.e. one commit back from where HEAD currently is) or HEAD~2 to move two parents back or any other number of parents back.  This can be useful because you can then make a new commit from the unchanged files in the staging area.  You could move back one commit to essentially redo your most recent commit, or you could move back multiple commits to essentially squash multiple commits into one commit.</p>     
            <p><strong>git reset --mixed SHA: </strong>Moves the head to the given SHA (first 7 chars, or use HEAD/HEAD~/HEAD~2/etc shorthand) and then updates the staging area to the files in that commit.  --mixed is the default so it can also be omitted and git reset SHA will assume --mixed. Using it with HEAD is useful when you want to "unstage" files in the staging area because it will set them back to the version in HEAD, but leave the working directory untouched.  If you specify a particular file name as in git reset --mixed SHA file.txt, then the first step of moving the head is skipped, but the second step of copying the file from the given SHA into the staging directory is still performed.  If used with HEAD for the SHA, then this is useful to "unstage" a single file.</p>
            <p><strong>git reset --hard SHA: </strong>Moves the head to the given SHA (first 7 chars, or use HEAD~/HEAD~2/etc shorthand) and then updates the staging area and working directory to the files in that commit.  This is potentially dangerous if the files in the working directory have not been saved to a commit.  If they have, then you could get them back using reflog.  If they haven't then they will be permanently lost.</p>

            <h3>Checkout</h3>
            <p><strong>git checkout HEAD filename: </strong>replace filename in working directory with version of filename in HEAD commit, can use . to replace all files</p>
            <p><strong>git checkout SHA filename: </strong>can also use a SHA (or first 7 characters of one) to replace the given filename in the working directory with the version of that file from the given SHA.  leave out filename to set entire working tree to the given SHA, this is intended to explore files/folders at the given commit and you shoudln't make commits while here</p>            
            <p><strong>git checkout -- filename: </strong>replaces filename in working directory with version of file in most recent commit</p>

            <p><strong>git reflog: </strong>the reflog provides 30 days of all history on a branch, both forward commits and backward
                resets, deletions of branches, and rebases</p>
                <ul>

                    <li><strong>gitk --all `git reflog | cut -c1-7`& </strong>use this comman to open a GUI showing the reflog so you can more
                        better see the organization of the reflog, which branches are out on their own, what commits are no longer part of it</li>
                </ul>

            <h2>Branching Commands</h2>
            <p><strong>git branch: </strong>shows all branches with a * next to the branch you are on, 
                the master branch should always be production-ready, so always do your work on a separate branch</p>
            <p><strong>git branch new_branch: </strong>creates a new branch with name new_branch, name should describe purpose of branch in a word or two, no whitespace
                e.g. refactor-authentication or user-content-cache-key</p>
                <ul>
                    <li><strong>git checkout -b newbranch </strong>this will create a new branch and also checkout to it right away</li>
                </ul>
            <p><strong>git checkout branch_name: </strong>switches you over to the branch with name branch_name</p>
                <ul>
                    <li>This updates your staging area and working directory with that branch's files, and future commits will be to that branch.  The command will check for any changes to your working directory before switching to ensure it doesn't overwrite any unsaved changes in the working directory.</li>
                </ul>
            <p><strong>git branch -d branch_name: </strong>deletes branch with branch_name, should be done once a branch has been merged into a receiver branch like master
                because the receiver will have all the commits from the branch in it after merging, can't delete the branch you're on, so switch to a different branch first</p>
                <ul>
                    <li><strong>git branch -D branchname: </strong>If a branch is not fully merged onto master, then -d won't let you delete it, use -D to do so</li>
                </ul>
            <p><strong>git rebase branchname: </strong>Adds new commits from branchname to the current checked out branch, where branchname is the branch that the currently
                checked out branch was branched off of.  This pulls in any new commits since you branched off of branchname, to make it look like you started your branch from
                the current version of branchname</p>
                <ul>
                    <li>This takes the current version of branchname, and "replays" the commits in your checked out branch starting from the latest commit of branchname</li>
                    <li>This changes the SHAs on all of the commits you've made in your checked out branch, so be careful if others are working on this branch as well
                        as it could mess them up</li>
                    <li>Rebase is good if clarity of history on the master branch is desired, because it creates an easy to follow linear history on the master
                        branch.  However, for projects where speed of delivery is more important, rebase may not be preferred, and instead merge will be used
                    </li>
                </ul>

            <h2>Merging Commands</h2>
            <p><strong>git merge branch_name: </strong>brings all commits from branch_name (giver branch) into the current branch (receiver branch)</p>
            <ul>
                <li>typically you checkout the master branch, then run this command to merge branch_name into master</li>
            </ul>
            <p><strong>Resolving merge conflicts: </strong></p>
            <ul>
                <li>any line of a file with conflicting changes between the branches will show an error msg, and the file will not be committed
                    and a special version of the file in the working directory will show the two conflicting alternatives for the line</li>
                <li>The receiver branch version of the line(s) will be between &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD and ======= 
                    while the giver branch version will be between the ======= and &gt;&gt;&gt;&gt;&gt;&gt;&gt; branchname</li>
                <li>to resolve, delete all of the special markup added by Git and keep only the version of the line you want or otherwise edit</li>
                <li>now you should stage the file, fix and stage any other conflicting files, and finally make a commit 
                    with the message "Resolve merge conflict" or similar</li>
            </ul>
            <p><strong>git merge --abort: </strong>After merging, if there are merge conflicts you don't want to deal with right now,
                then you can run this command to abort the merge, and it will return the working directory and staging area back to
                the last commit of the receiver branch</p>
            <p><strong>git merge --squash branchname: </strong>The --squash option will show the merge as a single commit on the receiver branch
                instead of adding all of the commits from the giver branch</p>
        
            <h2>Remote Commands</h2>
            <p><strong>creating a github repository: </strong>get started with a remote on github by creating an empty repository on github, which will provide instructions for adding it as a remote for a local project, the local project should have at least one commit so there is something to push</p>
                <ul>
                    <li><p>Github will give you option to create a readme, .gitignore, etc.  if you do, it will create an initial commit with these files added.
                        However, don't do this if you already have a local repository with commits to push to this github repository, as this will cause merge problems</p></li>
                </ul>
            <p><strong>git clone remote_location clone_name: </strong>good for branching, creates a copy of the git repository at remote_location (web address or filepath). the copy is named clone_name and placed in the current working directory, the remote will be aliased origin</p>
            <p><strong>git remote add origin remote_location: </strong>good for initial set up, run from local project directory to add a remote repository at remote_location (e.g. a github repository web url),
                remote will have alias origin in this example (common) but could be named something else</p>
            <p><strong>git remote set-url origin remote_location: </strong>allows you to change the url of a remote (origin in this example) to a different remote_location</p>
            <p><strong>git remote rm origin: </strong>run from local project directory, removes remote repository named origin</p>
            <p><strong>git remote -v: </strong>lists remotes for current working directory if directory is a git project, good to confirm remotes were added successfully</p>
            <p><strong>git branch -r: </strong>lists remote branches, remote branches named the same as local branches except start with the remote name, e.g. origin/master, origin/feature</p>
            <p><strong>git fetch origin: </strong>brings changes in from a remote, and puts them in your remote branches like origin/master, origin/feature, etc.
                the remote branches can then be merged to your local branch by checking out the local branch and then using git merge origin/master or git merge origin/feature,
                or whatever the name of the branch is you are merging</p>
            <p><strong>git pull origin: </strong>same as fetch but also will merge the corresponding remote branch into whatever local branch you have checked out</p>
            <p><strong>git push origin your_branch_name: </strong>copies the local your_branch_name branch to the corresponding remote origin branch,
                can leave off your_branch_name to simply copy the branch you have checked out.  However, you must include your_branch_name if you are pushing it up to origin and you haven't set up remote tracking for the branch.  Often used to copy a local feature branch to the remote repository named origin, so someone can review your branch and merge it to origin/master</p>
            <p><strong>Forking: </strong>To contribute to an open project on Github, you should use the fork feature in that project's repository
                to create a copy of the repository in your own Github account.  This allows you to safely work on the project on your own.
                Typically you should create a new branch after forking to do your work, and then you would submit a pull request when finished</p>
            <p><strong>Pull request: </strong>Within Github, when you are working on a branch of a repository, whether you're a core contributor
                with ability to push to the repository or you forked the project and worked on a branch on your own, you should make a pull request
                for the branch when its ready for review.  With a fork this is requesting from the owner to review your branch.  Pull requests
                have feedback functionality built in and code testing abilities built in. Once accepted, it can be merged into the master branch
                and its best practice to delete your branch to keep your repo clean with no unneccessary branches, as your commits and the pull request discussion become part of the destination branch</p>

            <h2>Github Workflow</h2>
            <ol>
                <li><strong>Branch: </strong>Create a branch off the <code>master</code> branch to work on a feature or fix.
                    Anything on the <code>master</code> branch should be deployable</li>
                <li><strong>Commit: </strong>Work on the new branch and make commits as you go, commit often!</li>
                <li><strong>Pull: </strong>Open a pull request to share what you have so far, get feedback or advice, or when you're ready for review
                    Use @mention system in Github to request feedback from specific people or teams
                    Good for contributing to open source projects or any project to allow review before merging to main branch</li>
                <li><strong>Review: </strong>Review pull request comments (written in markdown) and push additional commits to your branch if needed
                    to address comments.  Reviewers can see your additional commits and provide more comments</li>
                <li><strong>Deploy: </strong>Depending on team, deploy your branch to testing environment or directly to production
                    If there are problems, you can roll back by deploying the main branch</li>
                <li><strong>Merge: </strong>Now you can merge your code to the main branch.  Pull requests preserve a record of changes to your code
                    You can incorporate keywords into pull requests so that when it merges it closes an issue you fixed with the branch,
                    e.g. "Closes #32" will close issue 32 when merged into main</li>
            </ol>
        </main>
    </body>
</html>