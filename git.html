<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Git</title>
        <link href="./styles.css" type="text/css" rel="stylesheet">
    </head>
    <body>
        <header>
            <a href="./index.html">Home</a>
        </header>
        <main>
            <h2>Git Terms</h2>
            <p><strong>Git: </strong>a piece of software that allows for tracking of changes, 
                industry-standard version control system for web development, must be installed on your computer,
                can be used to track changes to any project that is composed of text files arranged in directories</p>
            <p><strong>Git project: </strong>consists of three parts listed below</p>
            <ul>
                <li><p><strong>Working Directory: </strong>make changes to files - additions, deletions, modifications</p></li>
                <li><p><strong>Staging Area: </strong>list changes made to the working directory, files ready for commit</p></li>
                <li><p><strong>Repository: </strong>where Git permanently stores changes as sequential versions (aka commits) of the project</p></li>
            </ul>
            <p><strong>Git workflow: </strong>edit files in working directory, add files to staging area, save changes (commit) to repository</p>
            <p><strong>Git collobarative workflow: </strong>fetch and merge changes from remote, create new local branch to work on feature, develop feature on new branch making commits along way, when done fetch and merge from remote again, push project branch to remote for review</p>
            <p><strong>Github: </strong>simply a cloud storage service popularly used for backing up Git repositories, you copy (push) your local repository to Github periodically to back it up, GitHub automatically displays contents of README.txt if in your repository</p>
            <p><strong>HEAD: </strong>the commit you are currently on in the sequence of commits</p>
            <p><strong>branch: </strong>essentially when a copy of the repository is made at a given commit, then creating two independent branches of future commits</p>
            <p><strong>master branch: </strong>at any branching point, one branch is actually considered the master branch, so there is a continuous master branch back to the beginning</p>
            <p><strong>remote: </strong>a git repository outside your git project that multiple collaborators can work on and merge changes to, could be on the web, a network, or just somewhere else on your computer</p>
            
            <h2>Git Project Standard Files</h2>
            <p><strong>readme </strong>documentation of project, good idea in general to document your projects</p>
            <p><strong>.gitignore: </strong>this file can be included in a git project's working directory to list all files and directories in 
                the working directory that git should ignore, simply list each file name or directory to ignore on its own line, start directory names 
                with /, e.g. /ignorethisdirectory. comment a line with #</p>
            <p><strong>license </strong></p>

            <h2>Basic Workflow Commands</h2>
            <p><strong>git init: </strong>turns the current working directory into a Git project</p>
                <ul>
                    <li>Can use git init in a local project directory that you've already worked on to start using version control</li>
                    <li>For a brand new project, helpful to use git init projectname to create a git project directory named projectname in the current directory</li>
                </ul>
            <p><strong>git status: </strong>check status of changes in working directory</p>
            <p><strong>git add filename: </strong>adds filename to the staging area, can list multiple filenames one after the other separated by a space or a single period adds all files in working directory (git add .)</p>
            <p><strong>git diff filename: </strong>for given filename, checks differences between working directory and staging area</p>
            <p><strong>git commit -m "message": </strong>permanently stores changes in staging area to repository, creates a "commit" with unique 40-character SHA</p>
            <ul>
                <li>message should be in present tense and less than 50 characters, start with capitol letter</li>
                <li>Often will group changes to multiple files under a single commit, should craft commits to tell an easy to understand story of changes</li>
                <li>Can also make commits in a Github repo by editing a file directly in Github, when you save changes it creates a commit for the changes to that file</li>
            </ul>
            <p><strong>git log: </strong>view chronological list of commits to repository</p>

            <h2>Backtracking Commands</h2>
            <p><strong>git show HEAD: </strong>shows log info and all committed changes for the HEAD commit</p>
            <p><strong>git checkout HEAD filename: </strong>replace filename in working directory with version of filename in HEAD commit</p>
            <p><strong>git reset HEAD filename: </strong>replace filename in staging area with version of filename in HEAD commit</p>
            <p><strong>git reset commit_SHA: </strong>sets the HEAD to the commit with the given commit_SHA, the commit_SHA should be the first 7 characters of the SHA</p>
            
            <h2>Branching Commands</h2>
            <p><strong>git branch: </strong>shows which branch you are on</p>
            <p><strong>git branch new_branch: </strong>creates a new branch with name new_branch, name should describe purpose of branch in a word or two, no whitespace
                e.g. refactor-authentication or user-content-cache-key</p>
            <p><strong>git checkout branch_name: </strong>switches you over to the branch with name branch_name</p>
            <p><strong>git branch -d branch_name: </strong>deletes branch with branch_name, often done after a branch has been merged into master and served its purpose</p>
            <p><strong>git merge branch_name: </strong>checkout the master branch, then run this command to merge branch_name (giver branch) into master (receiver branch)
            <br>any line of a file with conflicting changes between the branches will show an error msg, and the file in the working directory will show the two conflicting alternatives for the line
            <br>to resolve, delete all of the special markup added by Git and keep only the version of the line you want
            <br>now you can make a commit again, and the message for the commit shoudl be "Resolve merge conflict" or similar</p>
        
            <h2>Remote Commands</h2>
            <p><strong>creating a github repository: </strong>get started with a remote on github by creating an empty repository on github, which will provide instructions for adding it as a remote for a local project, the local project should have at least one commit so there is something to push</p>
                <ul>
                    <li><p>Github will give you option to create a readme, .gitignore, etc.  if you do, it will create an initial commit with these files added.
                        However, don't do this if you already have a local repository with commits to push to this github repository, as this will cause merge problems</p></li>
                </ul>
            <p><strong>git clone remote_location clone_name: </strong>good for branching, creates a copy of the git repository at remote_location (web address or filepath). the copy is named clone_name and placed in the current working directory, the remote will be aliased origin</p>
            <p><strong>git remote add origin remote_location: </strong>good for initial set up, run from local project directory to add a remote repository at remote_location (e.g. a github repository web address), remote will have alias origin, so it can be referred to with origin in commands</p>
            <p><strong>git remote rm origin: </strong>run from local project directory, removes remote repository named origin</p>
            <p><strong>git remote -v: </strong>lists remotes for current working directory if directory is a git project, good to confirm remotes were added successfully</p>
            <p><strong>git fetch: </strong>brings changes in from a remote, puts them in a remote branch called origin/master, which can then be merged to your local master branch with git merge origin/master</p>
            <p><strong>git push origin your_branch_name: </strong>copies a local branch (like one you made to develop a feature) called your_branch_name to the remote repository named origin, then someone can review your branch and merge it to the origin master</p>
        
            <h2>Github Workflow</h2>
            <ol>
                <li><strong>Branch: </strong>Create a branch off the <code>main</code> branch to work on a feature or fix.
                    Anything on the <code>main</code> branch should be deployable</li>
                <li><strong>Commit: </strong>Work on the new branch and make commits as you go, commit often!</li>
                <li><strong>Pull: </strong>Open a pull request to share what you have so far, get feedback or advice, or when you're ready for review
                    Use @mention system in Github to request feedback from specific people or teams
                    Good for contributing to open source projects or any project to allow review before merging to main branch</li>
                <li><strong>Review: </strong>Review pull request comments (written in markdown) and push additional commits to your branch if needed
                    to address comments.  Reviewers can see your additional commits and provide more comments</li>
                <li><strong>Deploy: </strong>Depending on team, deploy your branch to testing environment or directly to production
                    If there are problems, you can roll back by deploying the main branch</li>
                <li><strong>Merge: </strong>Now you can merge your code to the main branch.  Pull requests preserve a record of changes to your code
                    You can incorporate keywords into pull requests so that when it merges it closes an issue you fixed with the branch,
                    e.g. "Closes #32" will close issue 32 when merged into main</li>
            </ol>
        </main>
    </body>
</html>