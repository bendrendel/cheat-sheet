<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Webpack</title>
  </head>
  <body>
    <a href="../index.html">Home</a>

    <h1>Webpack</h1>

    <h2>Installing Webpack</h2>
    <p>
      Install webpack in a project's root directory with
      <code>npm intall webpack webpack-cli --save-dev</code> which will install
      webpack and the webpack command line interface, and the --save-dev (or -D)
      to save to devDependencies in package.json
    </p>

    <h2>Webpack Config</h2>
    <h3>Description</h3>
    <p>
      You don't have to use a config file, but you'll probably want to.  Without one,
      webpack will assume the entry point is src/index.js and the output will go to
      dist/main.js (bundled into a single file called main.js).  However you can configure 
      webpack by adding a file to the project's root directory called
      <code>webpack.config.js</code> to add configurations for webpack.
    </p>
    <p>
      The file should contain an exported object with the configuration
      settings.  Below is a complex example, but a simpler example would be a file that 
      simply contains <code>module.exports = { ... }</code> where the exported object 
      contains various configuration property/values.
    </p>
    <ul>
      <li>
        entry property with the relative path (relative to the config file) 
        to the file to process/bundle,
        which is the entry point to the app.  Webpack requires what's called an entry
        point, which is the main file to bundle.  The default entry point is 
        index.js in a 'src' directory and is what will be used if there is no 
        config file or no entry property in the config object.  So, if you want to go with the default
        set up, you will want to have an index.js file in a src directory.  It is
        not uncommon to use a different entry point like say ./application/home.js
      </li>
      <li>
        output property should be an object with a filename and path property,
        controlling output when webpack is run, default filename is main.js,
        default path is dist created in the project's root directory. path must
        be an absolute path, thus you'll need to use the path node core module
        which can get the full path of the project's root folder.  In the path property 
        of the output property, you would then put <code>path.resolve(__dirname, app)</code>
        to save the output file to ./app/ where ./ is from the root of the project where the config
        file is.  If the filename property was 'myoutput.js', then the output would be saved to
        ./app/myoutput.js.  This is why the path module is usually required in at the top 
        of webpack config files. When using the devServer, this file doesn't actually get created, it is just
        created virtually and served.  
      </li>
      <li>mode property webpack will use (development, production)</li>
      <li>
        Without a config file, you will keep getting errors that the mode 
        is not set and production will be the default mode used.  
        You can should set the mode in the config file, either to development or
        production.  Development bundles code that is still fairly readable and contains
        lots of comments explaining what's happening in the file, whereas production 
        produces bundled code that is fairly non readable and has no comments, but is more compact.  
        if not using the devServer, you can add a watch property, with a value of
        true.  Then when you run the webpack command (through a
        package.json script) it will stay running, and rebundle with every
        change to the entry file. press ^C to stop running.  However, if you
        are using the webpack devServer and it is set to hot, then you 
        should delete the watch property because the hot devServer will watch
        for changes automatically.
      </li>
      <li>
        In the build process, its helpful to set
        filename to '[name].[chunkhash].js', and also add a chunkFilename property
        set to this value also.  This will give the multiple js files output
        upon build a descriptive name (e.g. main for main js, separate
        names for code split modules, and vendor for npm packages), and will Also
        give them each a hash key in the name that only changes if the contents of
        the file are different (i.e. you change your code somehow).  This 
        makes the client redownload the file when the hash changes, instead of relying
        on cached versions of the file with an earlier hash.
      </li>
      <li>
        module property can take an object with a rules property set to an
        array, this array can hold objects that each define how webpack should
        handle different filetypes. the objects have a test property set to a
        regex that matches the filetypes to handle, and a type or use property to tell
        webpack what to do with those files.  Essentially it allows you to use ES6 import style 
        commands in your js entry file (or other js modules), to import files of that type, 
        and webpack will use the module property to figure out how to bundle them into your 
        output file.
        <ul>
          <li>
            Plain Text: The type property is simpler, and can be used for so called assets e.g. a plain .txt file.  For instance,
            You could have a plain .txt file with some descriptive text in it or a blog article in your 
            src folder called descriptiveText.txt.  You could import that text file into your entry js file 
            in your src folder (index.js say), by including 
            <code>import myText from './descriptiveText.txt</code> at the top of the js file.  
            Then you would have a variable named myText in your index.js and you could, for instance 
            set the innerHTML of a div equal to that variable to output the text contents into the rendered html.  
            Now, when bundling with webpack, webpack will see that .txt is being imported into your entry file, 
            and the module property will tell webpack what to do with that file.  For the text file, you want 
            basically no processing, and you want webpack to just grab the text in the file and copy it into 
            the bundled output file so it is there in the bundled file for use in the bundled javascript. 
            In this case, you would want your module property to look like:
            <pre><code>
              module: {
                rules: [
                  {
                    test: /\.txt$/i,
                    type: 'asset/source'
                  }
                ]
              }
            </code></pre>
          </li>
          <li>
            Images: As of Webpack 5, images no longer require a loader and can be included using Webpack's 
            asset system like a .txt file as shown above.  So, this would allow you to have an image, 
            say myImage.png in your src folder, and you could import this image into your entry point js file,
            say index.js, by including <code>import imageFile from './myImage.png';</code> at the top 
            of the file, and then you could use this image for example, to get an image element document reference 
            in your js file, and set the src attribute for that element directly equal to the image variable of your 
            import, i.e. <code>imgElem.src = imageFile</code>. For images the type is asset/resource instead of 
            asset/source because resource creates a file in the build for the image and imports it into the code 
            using a URL.  For your test regex, you could just look for .png files or .jpeg files or you could look for 
            multiple image file extensions at once as shown below:
            <pre><code>
              module: {
                rules: [
                  {
                    test: /\.(png|svg|jpg|jpeg|gif)$/i,
                    type: 'asset/resource'
                  }
                ]
              }
            </code></pre>
          </li>
          <li>
            Fonts: Again as of Webpack 5, fonts similar to images no longer require a loader.  They are added 
            as a asset/resource, and you can test for one or multiple font file types similar to images.  Fonts however 
            are not usually imported into your index.js entry file (or any other js module file in your project), rather
            they are usually imported into a .css file, perhaps your styles.css file in your src folder, or another css file 
            maybe in a subdirectory of the src folder.  To use it in your css file, you would use the standard syntax and include
            something similar to the following in your css file: 
            <code><pre>
              @font-face {
                font-family: 'Roboto-Black';
                src: url('./Roboto-Black.ttf');
              }
              
              h1 {
                font-family: 'Roboto-Black';
              }
            </pre></code>
            Now, in your config file, you would include something like below, and the font would get included in your build:
            <code><pre>
              module: {
                rules: [
                  {
                    test: /\.(woff|woff2|eot|ttf|otf)$/i,
                    type: 'asset/resource'
                  }
                ]
              }
            </pre></code>
          </li>
          <li>
            CSS: The use property can be used instead of the type property for more complex file 
            types that require something called a loader instead of a simple type declaration.
            These files may require one or multiple loaders to be bundled correctly into the output 
            file.    The use property is set to an array of package names that should handle 
            that filetype.  CSS for example requires two loaders, css-loader takes the css out of 
            a css file and adds it to the js code, and style-loader takes the output of css-loader
            and adds it to a style tag in the html document.  The use property takes an array, and applies
            the loaders in reverse order that they are listed in the array.  For css, css-loader runs 
            first, then style-loader, so style-loader comes first in the array.  To use these loaders,
            you first have to install the npm packages for them in the root directory by running 
            <code>npm install style-loader css-loader --save-dev</code>.  Then you can have a .css file 
            in your src folder, say myStyles.css and import it into your entry js file by putting 
            <code>import './myStyles.css</code> at the top.  The config file module property would then 
            include the following, and when you run the build command, the css will get applied to your
            index.html.
            <pre><code>
              module: {
                rules: [
                  {
                    test: /\.css$/i,
                    use: ['style-loader', 'css-loader']
                  }
                ]
              }
            </code></pre>
          </li>
          <li>
            The example below has rules for using style-loader and css-loader, 
            and also a more complex one for using postCSS-loader.  However, these css rules are
            put into their own variable outside the config object so that it can
            be easily altered for build vs development.  They both use css-loader and
            postcss-loader, thus that's part of the variable initialization.  But
            dev uses style-loader to simply bundle all the css into bundled.js, while
            build uses the MiniCSSExtractPlugin to save the css in its own file for
            distribution.  This is accomplished by using the unshift method on the use
            array within dev and build.  MiniCSSExtractPlugin is required in at top and
            also added to the plugins array for the build process.

            Finally, there is also the babel loader rule that is added to the modules
            property for the build process only.  This use of babel will make the js
            code added to your dist folder backwards-compatible with older web
            browsers.
          </li>
        </ul>
      </li>
      <li>
        optimization property, takes an object, can have splitChunks property
        shown below, which is only relevant for the build process, it will split
        the js from packages you use (direct dependencies) into its own js file,
        separate from the js you are writing custom.  This allows the client to
        cache the package js since it changes less frequently, and the client 
        won't have to download it again.  By default, it won't split the code into
        separate files if the package js is less than 20kb.  This is probably fine
        to go by, but you can add a second property to the object with the min file 
        size to use, in bytes.  Also including the minimize and minimizer
        properties, which minifies the css file in the build process. This requires
        installing the css minimizer plugin npm package, and requiring it in at top.
        Minimize must be set to true, and minimizer takes an array, where the first item
        indicates to use default settings, and the second specifies to use the 
        CssMinimizerPlugin.
      </li>
      <li>
        plugins property can store an array of webpack plugins that you install.
        <ul>
            <li>For instance, the CleanWebpackPlugin, which is required in at the beginning of the
            file, and then an instance is added to the plugins array.</li>
            <li>Also the MiniCSSExtractPlugin, also required in at the beginning, and then added to the plugins array, but with an argument that sets the filename of the css file it produces to include the
            file's chunkhash.  This and the CleanWebpack plugin are used on build only and pushed to the plugin array in the build process. </li>
            <li>There is also the HTMLWebpackPlugin, which is
            added in the main config initialization to be used for both build and dev - it
            takes two arguments, one being the file name to output, and the second being the
            filename to use as the starting point. Below there is a strikethrough example of how to use it
            if your site has a single page, and the main example shows how to use it if your site
            has multiple pages, in conjunction with the file system extra npm package, which is
            required in at the beginning.</li>
            <li>Finally the RunAfterCompile plugin is added to the build process only,
              and this is a custom made plugin defined near the top of the config file itself.
              This plugin is responsible for copying the assets folder into the dist folder,
              so that the html will be able to access the images and other assets of the site.
              It also relies on the fs-extra package which is required in at the beginning of the file.
              You could include additional code in the RunAfterCompile class declaration if you
              had other tasks you needed to do after the code is compiled.
            </li>
        </ul>
           
      </li>
    </ul>

    <h3>Example Webpack Config</h3>
    <pre>
        <code>
        const currentTask = process.env.npm_lifecycle_event;
        const path = require('path');
        const { CleanWebpackPlugin } = require('clean-webpack-plugin');
        const MiniCssExtractPlugin = require('mini-css-extract-plugin');
        const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');
        const HtmlWebpackPlugin = require('html-webpack-plugin');
        const fse = require('fs-extra');

        const postCSSPlugins = [
            require('postcss-import'),
            require('postcss-mixins'),
            require('postcss-simple-vars'),
            require('postcss-nested'),
            require('autoprefixer')
        ];

        class RunAfterCompile {
            apply(compiler) {
                compiler.hooks.done.tap('Copy images', () => {
                    fse.copySync('./app/assets/images', './dist/assets/images');
                })
            }
        }

        let cssConfig = {
          test: /\.css$/i,
          use: ['css-loader?url=false', { loader: 'postcss-loader', options: { postcssOptions: { plugins: postCSSPlugins } } }]
        };

        let pages = fse.readdirSync('./app').filter(file => {
            return file.endsWith('.html');
        }).map(page => {
            return new HtmlWebpackPlugin({filename: page, template: `./app/${page}`})
        });
            
        let config = {
            entry: './app/assets/scripts/App.js',
            plugins: pages,
            <s>plugins: [new HtmlWebpackPlugin({filename: 'index.html', template: './app/index.html'})],</s>
            <em>if your site only has a single page (i.e. index.html), then you can use this version of
              the plugins property and get rid of the one above and the variable pages, which is designed to
              iterate through each page and apply the HthmlWebpack Plugin.
            </em>
            module: {
                rules: [
                    cssConfig
                ]
            }
        };

        if (currentTask == 'dev') {
            cssConfig.use.unshift('style-loader');
            config.output = {
                filename: '[bundled.js]',
                path: path.resolve(__dirname, 'app')
            };
            config.devServer = {
                before: function (app, server) {
                    server._watch('./app/**/*.html');
                },
                contentBase: path.join(__dirname, 'app'),
                hot: true,
                port: 3000,
                host: '0.0.0.0'
            };
            config.mode = 'development';
        }

        if (currentTask == 'build') {
            config.module.rules.push({
                test: /\.js$/,
                exclude: /(node_modules)/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            });
            cssConfig.use.unshift(MiniCssExtractPlugin.loader);
            config.output = {
                filename: '[name].[chunkhash].js',
                chunkFilename: '[name].[chunkhash].js',
                path: path.resolve(__dirname, 'dist')
            };
            config.mode = 'production';
            config.optimization = {
                splitChunks: {chunks: 'all', minSize: 1000},
                minimize: true,
                minimizer: [`...`, new CssMinimizerPlugin()]
            }
            config.plugins.push(
                new CleanWebpackPlugin(),
                new MiniCssExtractPlugin({ filename: 'styles.[chunkhash].css' }),
                new RunAfterCompile()
            );
        }

        module.exports = config;
        </code>
    </pre>

    <h2>Running Webpack</h2>
    <p>
      In your package.json file, you'll usually want to define a script to run
      webpack.  Often you put it under the build command, so running npm run build
      will always run your build command, and in this case will be running webpack,
      but if you were using an alternative bundler, then you could have the build
      command run that instead, and it is helpful that npm run build always builds 
      the app regardless of the specific build tool being used.  However, you
      don't have to use build and could use any word or phrase you want, sometimes 
      people use 'dev' instead of 'build.  Additionally, for webpack you 
      can add the watch option to automatically look for updates to the source code 
      and rebuild if there are changes.  Notice if you do this, then when you run the build command, it becomes a continuously running process in your terminal, looking for updates and rebuilding (replacing the output files) with every update.  This may or may not be what you want, without the watch option, it just runs once and is done.  However, the watch option is a good workflow option for use with the dev server (more details in the dev server section).  The script in package.json would look like:
      <code><pre>
        "scripts": {
          "build": "webpack --watch",
        },
      </pre></code>
    </p>
    <p>
      run the script that runs webpack with e.g. npm run build to bundle the
      file in the entry property of the webpack config file to the output
      property of the config file. run it whenever you want to rebundle any changes to
      the entry file (unless you are using watch will constantly do this)
    </p>
    <p>The output file can be linked to the index.html through a script tag. Your index.html 
      can be served and the javascript output file will link in seamlessly if you are serving 
      index.html with the devSever or serving index.html in production.  However
      this should be omitted if using the HtmlWebpackPlugin, which handles linking for
      you both on the devServer and for the build process.
    </p>

    <h2>Build Process</h2>
    <p>Often, you'll use the dev server (below) for doing development, and include
      a script in package.json that runs webpack serve called start or dev or something like that.  There are different ways to configure dev server, described in the dev server section.  You may have the build process running continuously with the watch option, and then linking the 
      output file into your index.html and serving index.html with your dev server.  Or, you 
      may have webpack serve bundle your app.js entry file itself (instead of separately relying on
      a continuously running build --watch comand) but it will only bundle it to temporary memory, instead of outputting it to a file.
    </p>
    <p>The build process is what actually creates files that can be consumed by a client.</p>
    <ul>
      <li>In package.json, add a script <code>"build": "webpack"</code></li>
      <li>In webpack.config.js, add a line of code to the top of the file: 
        <code>const currentTask = process.env.npm_lifecycle_event;</code>, this will
        set currentTask to either "dev" or "build", depending on if npm run dev or npm
        run build was ran.  This will allow you to configure webpack differently for each.
      </li>
      <li>Now, for the config object that is exported form webpack.config.js, you can
        build the config object with separate properties depending on if the currentTask
        is dev or build.
      </li>
    </ul>
    <h3>Build output</h3>
    <ul>
      <li>Generally the built files should be output to a dist (distribution) folder. 
        By default webpack will output a single built file to dist/main.js, which will 
        be minified, have all the modules bundled into one file, etc.
      </li>
      <li>It will output your bundled js, with separate js for anything that is 
        code-split (i.e imported using import function upon some action), and
        package js if you use the optimization property in your webpack config file.
      </li>
      <li>Can install a package <code>npm install clean-webpack-plugin -D</code>
        and add to the config file, by requiring it in at top, and then adding
        it to the plugins property for the build config only.  Once you do this,
        every time you run the build script, all files in the dist folder will be
        deleted first, and then the newly bundled files will be added.  If a particular
        file has not changed, it will still have the same chunkhash, but if it has changed
        then the chunkhash will be different than the previous version that was deleted.
        This is what happens normally, except files wouldn't be deleted first, so you end
        up with duplicate files if they've changed, one with the old hash and one with the new.
        (If the hash didn't change then the file gets overwritten, so no duplicate).
      </li>
      <li>
        You will also handle css differently for build.  For dev you want to simply
        bundle the css in with bundled.js for simplicity, but for build you want the css
        to be in its own file.  This is accomplished with the MiniCSSExtractPlugin.
      </li>
      <li>Can use the HTML Webpack Plugin to handle linking the html file to the css
        file and the js files.  Since you are including the chunk hash on the file names,
        you will not be able to include links to the css file that is output or the js
        files that are output in your main index.html file in the app folder, because
        you won't know the hashes in advance.  The HTML webpack plugin will handle the linking
        for you, and you can leave out all style and script links in your index.html in the
        app folder.  When you run build, this plugin will make a copy of index.html and put it
        in your dist folder (a critical task in and of itself), and it will also add a style
        tag in the html file linking to the css file in the dist folder, and one or multiple
        script tags to the html file linking to all the js files in your dist folder (e.g.
        main, the packages js, and any code-split js).  Additionally, this plugin can be
        used with devServer for development, and you can leave out any script tag in the index.html
        for 'bundled.js' used for the devServer.  This will handle the linking for that as well.
      </li>
    </ul>

    <h2>Webpack Dev Server</h2>
    <p>Webpack can create a local server for development purposes, there are multiple 
      ways to configure it.
    </p>
    <p>
      First, you will need to install it in the root of your project with
      <code>npm install webpack-dev-server --save-dev</code>
    </p>
    <p>Then, in package.json, you'll probably want to add a script to run the 
      dev server.  You will probably already have a script to build like 
      <code>"build": "webpack --watch"</code>.  You can add a second script for the 
      webpack serve command which will start the dev server, a good option is to add 
      <code>"start": "webpack serve"</code>.  You could also replace your build command 
      to run 'webpack serve' instead of webpack (more details above in running webpack).
    </p>
    <p>If you are using the watch option with your build command, then one good workflow 
      option is to use the build process and serve process together.  By default, the serve process
      will be looking for an index.html file in your root directory to serve.  To make this work, you need to add a script tag to your index.html that links to the build output file, e.g.
      <code>&ltscript src="./dist/main.js">&lt/script></code>.  You don't want to link your index.html to the source code entry point file.  Once you've done this, now run <code>npm run build</code> in one terminal to start the continually running build process which will produce the output file (main.js) continuously as changes are made.  Then in a second terminal, you can run <code>npm run start</code> to start your development server, which will serve your index.html file, which will also be a continually running process and respond to the updates made as main.js is updated by the build process.
    </p>
    <p>As an alternative to the workflow above, you can configure the dev server in a different way.  In your entry js file, add the following logic that will allow the js to accept hot updates from the dev server:
    </p>
    <pre><code>
      if (module.hot) {
        module.hot.accept();
      }
    </code></pre>
    <p>
      With this workflow, you'll also need to add a property to the webpack 
      config file (included in the example above) called devServer, which is set to an 
      object with the following properties.  For the build/start joint processes workflow described
      earlier you don't need to add this to the config file, though some options might be relevant 
      if you need them like contentBase to change where your index.html is if needed.
    </p>
    <ul>
      <li>before is set to an anonymous function that will make the devServer
        reload the page everytime you make changes to index.html or other html
        files in your project.  without this property, the devServer is only
        watching for changes to the js file that it is bundling (which also
        watches for css changes since the css is imported into the js file)
      </li>
      <li>contentBase is set to the directory you want to serve, the directory
        that contains index.html
      </li>
      <li>
        hot set to true will make the server inject the new css and js to the
        browser upon change, not requiring a full reload of the page.
        if set to true, then you shouldn't use the watch property in the config object, because a hot devServer will automatically watch for changes, rebundle, and inject
      </li>
      <li>
        port set to e.g. 3000, set to 8080 by default.  the served page can be
        accessed at <code>localhost:3000</code> or whatever number you set
        the port to
      </li>
      <li>host can be set so that the page is served on your local network
        and can be accessed e.g. on your iphone if connected to the same network.  First find your local IP address (settings > network on mac) which starts with 192.168.X.X.  Instead of <code>localhost:3000</code> you can visit the page at <code>192.168.X.X:3000</code>
      </li>
    </ul>    

    <h2>CSS Support</h2>
    <h3>Overview</h3>
    <p>
      CSS Preprocessors like SASS LESS and Stylus, and post-processors like
      PostCSS allow you to write CSS files with special features like variables,
      nested selectors, and will auto-prefix properties that need a prefix like
      moz or webkit
    </p>
    <p>
      Out of the box, webpack only bundles javascript. Additional npm packages
      are needed to support css and PostCSS
    </p>

    <h3>Supporting CSS</h3>
    <p>
      Add an import statement to the top of your 'entry' js file that imports
      the css file you want, e.g. <code>import '../styles/styles.css'</code>
    </p>
    <p>
      Use <code>npm install css-loader style-loader --save-dev</code> to install
      the css-loader package and style-loader package and add it to the dev
      dependencies, these will respectively support importing the css to your
      entry js file, and applying the styles to your html
    </p>
    <p>
      In the webpack config file, ensure to add a module: rules array object
      that tests for css files and uses style-loader and css-loader (shown in
      the example config file above)
    </p>
    <p>
      instead of 'css-loader' in the config file, use 'css-loader?url=false' to
      prevent it from handling any immages referenced in the css. I think this allows
      you to handle images with lazy-sizes.
    </p>
    <p>style-loader should only be used with the dev process, as it will add the css
      to bundled.js for simplicity.  For the build process, you should use MiniCSSExtractPlugin
      to put the css in it's own file for distribution.
    </p>
    <p>Can also install the minimizer plugin with 
      <code>npm install css-minimizer-webpack-plugin -D</code> which is only
      used for the build process and minifies the css file in the dist folder, for quicker loading
      on the client.  the plugin must be required in the webpack config file, and
      added to the optimization property as shown in the example config above.
    </p>

    <h3>Supporting PostCSS</h3>
    <p>
      Make sure there's an import statement in your 'entry' js file as discussed
      above
    </p>
    <p>
      Now use npm to install <code>postcss-loader</code>, similarly to above
    </p>
    <p>
      You'll also want to use npm to install the features you want, e.g
      <code
        >npm install postcss-simple-vars postcss-nested autoprefixer
        postcss-import postcss-mixins --save-dev</code
      >
      to install variables, nested css, autoprefixing, imports, and mixins
    </p>
    <p>v  
      In the webpack config file add to the module rules array that tests for
      css files and use an object with a loader property and options property with the plugins listed (shown in example above).
    </p>
    <ul>
      <li>
        vars can be made by declaring e.g.<code>$bluecolor: #2f557s</code> in
        the css, and then can use that var name elsewhere in css, e.g.
        <code>color: $bluecolor</code>
      </li>
      <li>
        <p>nested css can be written as in</p>
        <pre><code>
          .class { 
            .nested-class { 
              font-size: 1rem;

              @media (min-width: 530px) {
                font-size: 2rem;
              }
            }
          }
          </code></pre>
        <p>
          PostCSS will turn this into a single selector of
          <code>.class .nested-class {color: blue}</code>
        </p>
        <p>
          You can use an ampersand in the nested selectors, to make css copy the
          top classes name for more control over the final selector and avoid
          multiple classes in the final selector. E.g.
        </p>
        <pre><code>
          .block { 
            &__element { 
              color: blue
            } 
          }
          </code></pre>
        <p>Will turn into <code>.block__element {color: blue}</code></p>
      </li>
      <li>
        imports can be used by having a main css file and importing other css
        files to it, by putting <code>@import 'mymodule.css';</code> at top of
        main css file to import mymodule.css. @import is a native css feature,
        but using the postcss imports plugin will import all of the imported css
        code before going to the client, so that the client doesn't have to
        download multiple css files, which it would have to do using the native
        @import. css files to import may be named with an underscore prefix to
        indicate they are "partial files", e.g. _mymodule.css. can also import a
        node module package like normalize.css without having to specify exact
        path, e.g. @import "normalize.css" will know to find it in the node
        modules folder of the project
      </li>
      <li>
        mixins can be used by creating a _mixins.css file and defining mixins that can be used elsewhere thanks to importing them into your main style file.  mixins are essentially prewritten pieces of css code, e.g. 
        <pre><code>
        @define-mixin atSmall {
            @media (min-width: 530px) {
                @mixin-content;
            }
        }
        </code></pre>
        which can then be used in your css files, e.g.
        <pre><code>
        @mixin atSmall {
          font-size: 2.9rem
        }
        </code></pre>
      </li>
    </ul>

    <h2>Multipage Website</h2>
    <p>Webpack can work well for sites with about 10 pages or less, any bigger you
      should consider a static site generator
    </p>
    <p>Additional pages should be stored in your app folder in the same place as
      index.html
    </p>
    <p>Install <code>npm install fs-extra -D</code>, and require it in at the top
    of the webpack config file.  Then you can use it to help you iterate through
    all of the pages in your site to use the HtmlWebpackPlugin on (see example
    config file above), which handles all the linking to scripts
    </p>

    <h2>Supporting older browsers</h2>
    <p>Using babel, you can write the latest modern javascript in your app folder,
      and it will be compiled to backward compatible javascript in the dist folder so it
      can run on browsers that don't support the latest js.
    </p>
    <p>Install <code>npm install @babel/core @babel/preset-env babel-loader -D</code> in
    the root directory of the project</p>
    <p>now all you need to do is make sure to add a rule to use babel-loader to the
      module property of the webpack config file, as shown above in the example
      config file.
    </p>


    <h2>Webpack project file structure</h2>
    <p>Using modular CSS BEM architecture</p>
    <ul>
      <li>app/</li>
      <ul>
        <li>assets/</li>
        <ul>
          <li>images/</li>
          <ul>
            <li>icons/</li>
          </ul>
          <li>scripts/</li>
          <ul>
            <li>modules/ <em>a folder containing js modules like classes, ideally each module has a single purpose like defining a class that is exported using ES6 export default or named exports and is then imported to App.js and used there.</em></li>
            <li>App.js <em>entry js file, which imports js modules from the modules scripts/modules folder e.g. <code>import MyClass from './modules/MyClass.js';</code>, and also imports the styles.css file which in turn imports all the css files e.g. <code>import '../styles/styles.css';</code></em></li>
          </ul>
          <li>styles/</li>
          <ul>
            <li>
              base/
              <em>
                a folder containing _global.css for global styles, and
                _variable.css containing css variables that can be used
                throughout all other css files, and _mixins.css for mixin definitions that can be used throughout the project
              </em>
            </li>
            <li>
              modules/
              <em>
                a folder containing css files for each block in the design under
                BEM css architecture
              </em>
            </li>
            <li>
              styles.css
              <em
                >main css file containing only @import statements to
                single-responsibility css files from base css, module css, and
                node module css (like normalize.css), e.g. <code>@import './base/_mixins.css'</code></em
              >
            </li>
          </ul>
        </ul>

        <li>
          index.html <em>main html file, can have script tag linking to bundled.js
            or leave off script tag if using html-webpack-plugin to handle linking
          </em>
        </li>
        <li>about.html</li>
        <li>contact.html</li>
      </ul>

      <li>dist</li><em>contains files for distribution</em>
      <li>node_modules/</li>
      <li>.gitignore</li>
      <li>package-lock.json</li>
      <li>package.json</li>
      <li>webpack.config.js</li>
    </ul>

    <h2>Example App.js file for Webpack Project</h2>
    <h3>Import of styles and modules</h3>
    <p>Imports style sheet and custom modules at top.  Also importing the lazysizes npm package to be used
      for lazy loading of images.  For custom modules, often all you need to do is run the constructor
      of the imported class module.  In this case all you need to do is use new ClassModule(), so that
      the constructor runs, and you don't need to save the instance of the class to a variable, unless
      you need to use that variable later on, or as used in code-splitting.
    </p>

    <h3>Event Emitters</h3>
    <p>One powerful technique is to use the npm eventemitter package in your modules.  Then your modules
      can emit custom events, and in your App.js file, you can have methods in other modules run when those
      events are emitted.  To do this, you'll need to save your module class instances to variables so you
      can call specific methods on them as event handlers.
    </p>

    <h3>Code Splitting</h3>
    <p>Inlcudes code splitting, where modal module gets loaded only once a button is clicked.
      This saves the modal code in a variable called modal, and does not load the code again
      if the modal variable has been initialized with the code.  Import the modal module
      using the import function.  can use the webpackChunkName comment to give a name to the Additional
      js file that the browser will download once the button is clicked.  Import returns a promise,
      and must use the returned value x with new x.default() to create an instance of the module class.
      Use set timeout before running a method of the class instance if it has just been loaded to make sure 
      everything is fully loaded.
    </p>

    <code><pre>
      import '../styles/styles.css';
      import 'lazysizes'
      import MobileMenu from './modules/MobileMenu.js';

      new MobileMenu();
      let modal;

      document.querySelector('#button').addEventListener('click', e => {
        if(!modal) {
          import(/* webpackChunkName: 'modal' */ './modules/Modal.js').then((x) => {
            modal = new x.default();
            setTimeout(() => modal.openTheModal(), 20);
          }).catch(() => console.log('Error'));
        } else {
          modal.openTheModal();
        }
      })
    </pre></code>

    <h2>Example js class module for webpack project</h2>
    <p>This class would be saved in the js modules folder.  It would
      be imported into the App.js file and a variable would be initialized
      in App.js to an instance of the class.  This initialization will
      run the constructor function.
    </p>
    <code>filename: MobileMenu.js</code>
    <code>
      <pre>
        class MobileMenu {
          constructor {
            this.mobileMenu = document.querySelector('.mobile-menu');
              <em>//since the constructor runs when initialized in App.js,
                this will select the menu element in index.html
              </em>
            this.events();
          }

          events() {
            this.mobileMenu.addEventListener('click', () => this.handleClick());
            <em>//the event listener function needs to be put inside an arrow 
              function because inside an arrow function, 'this' will bind to the
              object so it can use handleClick.  Without the arrow function, 'this'
              would bind to the event target.  Arrow functions cannot bind
              'this', so 'this' takes on the value of the outer context.
            </em>
          }

          handleClick() {
            console.log('clicked!');
          }

        }
      </pre>
    </code>

    <h2>Deploying to Github Pages</h2>
    <ul>
      <li>Github Pages requires the public folder to be named docs instead of dist.  Most other
        hosting services allow you to call it what you want and dist is a common name.  But for Github
        you need to change it by changing the webpack config file in two places: the run after compile
        class and the output property of the build process.  Then delete your dist folder if it exists
        and re run the build process to create the docs folder.
      </li>

      <li>Assuming you are using github for your repo hosting, push all your changes to the master branch.
        Now, go to your repo on github.com, and go to settings > Github Pages.  Under Source, choose
        your master branch, and then choose the Docs folder and click save.  This should produce a url for the
        site and it is live on the web!  The url will be https://bendrendel.github.io/repo-name/
      </li>

      <li>The url might 10-20 minutes to go live.  To speed this up, try making a new commit to your project
        and push it back up to github, which should force a re-deploy and make it available.
      </li>

      <li>Github also allows you to add a domain name if you purchase one from a domain name registrar</li>
    </ul>

    <h2>Deploying on Netlify</h2>
    <ul>
      <li>Create a new site on netlify and connect it to your github repo for a webpack project.
        Ensure that on netlify you specify the build commmand of 'npm run build' and that you specify
        the public directory built by npm run build, i.e. type in <code>dist</code> or <code>docs</code>
      </li>
      <li>You can actually delete the dist or docs folder from your repo.  Every time you push
        changes to the master branch (or whatever publish branch you choose) in your github repo, netlify will detect the change and run the build command.  Netlify looks at your package.json
        file and downloads all the npm dependencies and devDependencies, and runs the build command
        on their hardware, creating the build directory.  It hosts the built directory or public directory.  You can see all the deploys Netlify makes each time you push to github.
      </li>
      <li>
        You may want to still have the docs or dist folder in your project, because you may be testing
        your build command for example.  In this case, you can add <code>docs/</code> or 
        <code>dist/</code> on its own line in your .gitignore file so that the directory doesn't
        get copied to github.
      </li>
      <li>Besides the build tools on Netlify, you also of course have access to the AWS cloud functions,
        form submission controls, and other Netlify features.
      </li>
    </ul>

    <h2>Integrating React</h2>
    <p>You can start integrating react into a webpack project, even if you didn't have the luxury
      of starting the project from scratch with react using create-react-app
    </p>
    <ul>
      <li>First install react & react-dom in the root directory of the project with 
        <code>npm install react react-dom</code> and also install a babel package with
        <code>npm install @babel/preset-react -D</code>
      </li>
      <li>
        Now you can make a react component in your script modules folder, e.g. a file named
        MyAmazingComponent.js with the following code:
        <code><pre>
        import React from 'react';

        function MyAmazingComponent() {
            return (
            &ltdiv>
                &lth1 className="section-title section-title--blue">This is my amazing react component!&lt/h1>
                &ltp>React is great, the sky is blue
                and the grass is green.
                &lt/p>
            &lt/div>
            );
        }

        export default MyAmazingComponent;
        </pre></code>
      </li>
      <li>Now, in App.js you'll want to include <code>import React from 'react'</code> and 
        <code>import ReactDOM from 'react-dom'</code>, and you will also import your component 
        <code>import MyAmazingComponent from './modules/MyAmazingComponent.js'</code>, and then you 
        can render your component with ReactDOM render: 
        <code>ReactDOM.render(&ltMyAmazingComponent />, document.querySelector('#my-react-example'));</code>
        Or you can as usual have multiple components, and have components render other components, e.g. 
        you could include <code>&ltAnotherComponent /></code> in the returned jsx of the MyAmazingComponent
        function above, and import the AnotherComponent into the MyAmazingComponent module.
      </li>
      <li>
        Now, you'll need to alter your webpack config file so that js files
        use the babel react preset you installed.  The example config file
        above only uses bable for the build process and uses the preset that
        makes your code backward-compatible with older browsers, which isn't necessary
        for your dev server since you the developer will likely be using an up to date
        browser.  However, we need the react preset for both the dev server and the build
        process.  So, the best way to do this is delete the config.module.rules.push() command
        from the build process entirely, and instead add all that to the initialization
        of config plus add the react preset to it, so that this will all apply to both the
        dev server and the build process.  The config initialization should now be:
        <code>
          <pre>
          let config = {
              entry: './app/assets/scripts/App.js',
              plugins: pages,
              module: {
                  rules: [
                      cssConfig,
                      {
                          test: /\.js$/,
                          exclude: /(node_modules)/,
                          use: {
                              loader: 'babel-loader',
                              options: {
                                  presets: ['@babel/preset-react', '@babel/preset-env']
                              }
                          }
                      }
                  ]
              }
          };
          </pre>
        </code>
      </li>
    </ul>
  </body>
</html>
