<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Webpack</title>
  </head>
  <body>
    <a href="../index.html">Home</a>

    <h1>Webpack</h1>

    <h2>Installing Webpack</h2>
    <p>
      Install webpack in a project's root directory with
      <code>npm intall webpack webpack-cli --save-dev</code> which will install
      webpack and the webpack command line interface, and the --save-dev (or -D)
      to save to devDependencies in package.json
    </p>

    <h2>Webpack Config</h2>
    <h3>Description</h3>
    <p>
      Add a file to the project's root directory called
      <code>webpack.config.js</code> to add configurations for webpack.
    </p>
    <p>
      The file should contain an exported object with the configuration
      settings, such as:
    </p>
    <ul>
      <li>
        entry property with the relative path to the file to process/bundle,
        which is the entry point to the app
      </li>
      <li>
        output property should be an object with a filename and path property,
        controlling output when webpack is run, default filename is main.js,
        default path is dist created in the project's root directory.path must
        be an absolute path, thus you'll need to use the path node core module
        which generates the absolute path of the project. e.g.
        path.resolve(__dirname, app) will save the file named filename to
        ./app/filename.  This is why path is required in at the beginning of the file.
      </li>
      <li>mode property webpack will use (development, production)</li>
      <li>
        if not using the devServer, you can add a watch property, with a value of
        true.  Then when you run the webpack command (through a
        package.json script) it will stay running, and rebundle with every
        change to the entry file. press ^C to stop running.  However, if you
        are using the webpack devServer and it is set to hot, then you 
        should delete the watch property because the hot devServer will watch
        for changes automatically.
      </li>
      <li>
        In the build process, its helpful to set
        filename to '[name].[chunkhash].js', and also add a chunkFilename property
        set to this value also.  This will give the multiple js files output
        upon build a descriptive name (e.g. main for main js, separate
        names for code split modules, and vendor for npm packages), and will Also
        give them each a hash key in the name that only changes if the contents of
        the file are different (i.e. you change your code somehow).  This 
        makes the client redownload the file when the hash changes, instead of relying
        on cached versions of the file with an earlier hash.
      </li>
      <li>
        module property can take an object with a rules property set to an
        array, this array can hold objects that each define how webpack should
        handle different filetypes. the objects have a test property set to a
        regex that matches the filetypes to handle, and a use property that is
        set to an array of package names that should handle that filetype. the
        example below has rules for using style-loader and css-loader, and also
        a more complex one for using postCSS-loader.  However, these css rules are
        put into their own variable outside the config object so that it can
        be easily altered for build vs development.  They both use css-loader and
        postcss-loader, thus that's part of the variable initialization.  But
        dev uses style-loader to simply bundle all the css into bundled.js, while
        build uses the MiniCSSExtractPlugin to save the css in its own file for
        distribution.  This is accomplished by using the unshift method on the use
        array within dev and build.  MiniCSSExtractPlugin is required in at top and
        also added to the plugins array for the build process.
      </li>
      <li>
        optimization property, takes an object, can have splitChunks property
        shown below, which is only relevant for the build process, it will split
        the js from packages you use (direct dependencies) into its own js file,
        separate from the js you are writing custom.  This allows the client to
        cache the package js since it changes less frequently, and the client 
        won't have to download it again.  By default, it won't split the code into
        separate files if the package js is less than 20kb.  This is probably fine
        to go by, but you can add a second property to the object with the min file 
        size to use, in bytes.  Also including the minimize and minimizer
        properties, which minifies the css file in the build process. This requires
        installing the css minimizer plugin npm package, and requiring it in at top.
        Minimize must be set to true, and minimizer takes an array, where the first item
        indicates to use default settings, and the second specifies to use the 
        CssMinimizerPlugin.
      </li>
      <li>
        plugins property can store an array of webpack plugins that you install.  For
        instance, the CleanWebpackPlugin, which is required in at the beginning of the
        file, and then an instance is added to the plugins array. Also the MiniCSSExtractPlugin,
        also required in at the beginning, and then added to the plugins array, but with
        an argument that sets the filename of the css file it produces to include the
        file's chunkhash.
      </li>
    </ul>

    <h3>Example Webpack Config</h3>
    <pre>
        <code>
        const currentTask = process.env.npm_lifecycle_event;
        const path = require('path');
        const { CleanWebpackPlugin } = require('clean-webpack-plugin');
        const MiniCssExtractPlugin = require('mini-css-extract-plugin');
        const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

        const postCSSPlugins = [
            require('postcss-import'),
            require('postcss-mixins'),
            require('postcss-simple-vars'),
            require('postcss-nested'),
            require('autoprefixer')
        ];

        let cssConfig = {
          test: /\.css$/i,
          use: ['css-loader?url=false', { loader: 'postcss-loader', options: { postcssOptions: { plugins: postCSSPlugins } } }]
        };
            
        let config = {
            entry: './app/assets/scripts/App.js',
            module: {
                rules: [
                    cssConfig
                ]
            }
        };

        if (currentTask == 'dev') {
            cssConfig.use.unshift('style-loader');
            config.output = {
                filename: '[bundled.js]',
                path: path.resolve(__dirname, 'app')
            };
            config.devServer = {
                before: function (app, server) {
                    server._watch('./app/**/*.html');
                },
                contentBase: path.join(__dirname, 'app'),
                hot: true,
                port: 3000,
                host: '0.0.0.0'
            };
            config.mode = 'development';
        }

        if (currentTask == 'build') {
            cssConfig.use.unshift(MiniCssExtractPlugin.loader);
            config.output = {
                filename: '[name].[chunkhash].js',
                chunkFilename: '[name].[chunkhash].js',
                path: path.resolve(__dirname, 'dist')
            };
            config.mode = 'production';
            config.optimization = {
                splitChunks: {chunks: 'all', minSize: 1000},
                minimize: true,
                minimizer: [`...`, new CssMinimizerPlugin()]
            }
            config.plugins = [
              new CleanWebpackPlugin(),
              new MiniCssExtractPlugin({filename: 'styles.[chunkhash].css'})
            ]
        }

        module.exports = config;
        </code>
    </pre>

    <h2>Running Webpack</h2>
    <p>
      In your package.json file, add a script to run the 'webpack' command such
      as
      <code>"dev": "webpack"</code>
    </p>
    <p>
      run the script that runs webpack with e.g. npm run build to bundle the
      file in the entry property of the webpack config file to the output
      property of the config file. run it whenever to rebundle any changes to
      the entry file
    </p>
    <p>The output file can be linked to the index.html through a script tag</p>
    <p>If you are using the webpack dev server package, then instead of
      the webpack command, use webpack server, i.e. <code>"dev": "webpack serve"</code>
    </p>

    <h2>Build Process</h2>
    <p>Often, you'll use the dev server (below) for doing development, and include
      a script in package.json called dev that runs webpack serve.  Webpack serve will
      bundle your app.js entry file but it will only bundle it to temporary memory, instead
      of outputting it to a file.  This can be accessed in your browser at the correct
      local host port.
    </p>
    <p>The build process is what actually creates files that can be consumed by a client.</p>
    <ul>
      <li>In package.json, add a script <code>"build": "webpack"</code></li>
      <li>In webpack.config.js, add a line of code to the top of the file: 
        <code>const currentTask = process.env.npm_lifecycle_event;</code>, this will
        set currentTask to either "dev" or "build", depending on if npm run dev or npm
        run build was ran.  This will allow you to configure webpack differently for each.
      </li>
      <li>Now, for the config object that is exported form webpack.config.js, you can
        build the config object with separate properties depending on if the currentTask
        is dev or build.
      </li>
    </ul>
    <h3>Build output</h3>
    <ul>
      <li>Build files should be output to a dist (distribution) folder</li>
      <li>It will output your bundled js, with separate js for anything that is 
        code-split (i.e imported using import function upon some action), and
        package js if you use the optimization property in your webpack config file.
      </li>
      <li>should install a package <code>npm install clean-webpack-plugin -D</code>
        and add to the config file, by requiring it in at top, and then adding
        it to the plugins property for the build config only.  Once you do this,
        every time you run the build script, all files in the dist folder will be
        deleted first, and then the newly bundled files will be added.  If a particular
        file has not changed, it will still have the same chunkhash, but if it has changed
        then the chunkhash will be different than the previous version that was deleted.
        This is what happens normally, except files wouldn't be deleted first, so you end
        up with duplicate files if they've changed, one with the old hash and one with the new.
        (If the hash didn't change then the file gets overwritten, so no duplicate).
      </li>
      <li>
        You will also handle css differently for build.  For dev you want to simply
        bundle the css in with bundled.js for simplicity, but for build you want the css
        to be in its own file.  This is accomplished with the MiniCSSExtractPlugin.
      </li>
    </ul>

    <h2>Webpack Dev Server</h2>
    <p>
      Install in root of project with
      <code>npm install webpack-dev-server --save-dev</code>
    </p>
    <p>In package.json set your webpack script to run 'webpack serve' instead
      of webpack (see details above in running webpack)
    </p>
    <p>In your entry js file, add the following logic that will allow the js
      to accept hot updates from the dev server:
    </p>
    <pre><code>
      if (module.hot) {
        module.hot.accept();
      }
    </code></pre>
    <p>
      Add a property to the webpack config file (see example above) called
      devServer, which is set to an object with the following properties.
    </p>
    <ul>
      <li>before is set to an anonymous function that will make the devServer
        reload the page everytime you make changes to index.html or other html
        files in your project.  without this property, the devServer is only
        watching for changes to the js file that it is bundling (which also
        watches for css changes since the css is imported into the js file)
      </li>
      <li>contentBase is set to the directory you want to serve, the directory
        that contains index.html
      </li>
      <li>
        hot set to true will make the server inject the new css and js to the
        browser upon change, not requiring a full reload of the page.
        if set to true, then you shouldn't use the watch property in the config object, because a hot devServer will automatically watch for changes, rebundle, and inject
      </li>
      <li>
        port set to e.g. 3000, set to 8080 by default.  the served page can be
        accessed at <code>localhost:3000</code> or whatever number you set
        the port to
      </li>
      <li>host can be set so that the page is served on your local network
        and can be accessed e.g. on your iphone if connected to the same network.  First find your local IP address (settings > network on mac) which starts with 192.168.X.X.  Instead of <code>localhost:3000</code> you can visit the page at <code>192.168.X.X:3000</code>
      </li>
    </ul>    

    <h2>CSS Support</h2>
    <h3>Overview</h3>
    <p>
      CSS Preprocessors like SASS LESS and Stylus, and post-processors like
      PostCSS allow you to write CSS files with special features like variables,
      nested selectors, and will auto-prefix properties that need a prefix like
      moz or webkit
    </p>
    <p>
      Out of the box, webpack only bundles javascript. Additional npm packages
      are needed to support css and PostCSS
    </p>

    <h3>Supporting CSS</h3>
    <p>
      Add an import statement to the top of your 'entry' js file that imports
      the css file you want, e.g. <code>import '../styles/styles.css'</code>
    </p>
    <p>
      Use <code>npm install css-loader style-loader --save-dev</code> to install
      the css-loader package and style-loader package and add it to the dev
      dependencies, these will respectively support importing the css to your
      entry js file, and applying the styles to your html
    </p>
    <p>
      In the webpack config file, ensure to add a module: rules array object
      that tests for css files and uses style-loader and css-loader (shown in
      the example config file above)
    </p>
    <p>
      instead of 'css-loader' in the config file, use 'css-loader?url=false' to
      prevent it from handling any immages referenced in the css. I think this allows
      you to handle images with lazy-sizes.
    </p>
    <p>style-loader should only be used with the dev process, as it will add the css
      to bundled.js for simplicity.  For the build process, you should use MiniCSSExtractPlugin
      to put the css in it's own file for distribution.
    </p>
    <p>Can also install the minimizer plugin with 
      <code>npm install css-minimizer-webpack-plugin -D</code> which is only
      used for the build process and minifies the css file in the dist folder, for quicker loading
      on the client.  the plugin must be required in the webpack config file, and
      added to the optimization property as shown in the example config above.
    </p>

    <h3>Supporting PostCSS</h3>
    <p>
      Make sure there's an import statement in your 'entry' js file as discussed
      above
    </p>
    <p>
      Now use npm to install <code>postcss-loader</code>, similarly to above
    </p>
    <p>
      You'll also want to use npm to install the features you want, e.g
      <code
        >npm install postcss-simple-vars postcss-nested autoprefixer
        postcss-import postcss-mixins --save-dev</code
      >
      to install variables, nested css, autoprefixing, imports, and mixins
    </p>
    <p>v  
      In the webpack config file add to the module rules array that tests for
      css files and use an object with a loader property and options property with the plugins listed (shown in example above).
    </p>
    <ul>
      <li>
        vars can be made by declaring e.g.<code>$bluecolor: #2f557s</code> in
        the css, and then can use that var name elsewhere in css, e.g.
        <code>color: $bluecolor</code>
      </li>
      <li>
        <p>nested css can be written as in</p>
        <pre><code>
          .class { 
            .nested-class { 
              font-size: 1rem;

              @media (min-width: 530px) {
                font-size: 2rem;
              }
            }
          }
          </code></pre>
        <p>
          PostCSS will turn this into a single selector of
          <code>.class .nested-class {color: blue}</code>
        </p>
        <p>
          You can use an ampersand in the nested selectors, to make css copy the
          top classes name for more control over the final selector and avoid
          multiple classes in the final selector. E.g.
        </p>
        <pre><code>
          .block { 
            &__element { 
              color: blue
            } 
          }
          </code></pre>
        <p>Will turn into <code>.block__element {color: blue}</code></p>
      </li>
      <li>
        imports can be used by having a main css file and importing other css
        files to it, by putting <code>@import 'mymodule.css';</code> at top of
        main css file to import mymodule.css. @import is a native css feature,
        but using the postcss imports plugin will import all of the imported css
        code before going to the client, so that the client doesn't have to
        download multiple css files, which it would have to do using the native
        @import. css files to import may be named with an underscore prefix to
        indicate they are "partial files", e.g. _mymodule.css. can also import a
        node module package like normalize.css without having to specify exact
        path, e.g. @import "normalize.css" will know to find it in the node
        modules folder of the project
      </li>
      <li>
        mixins can be used by creating a _mixins.css file and defining mixins that can be used elsewhere thanks to importing them into your main style file.  mixins are essentially prewritten pieces of css code, e.g. 
        <pre><code>
        @define-mixin atSmall {
            @media (min-width: 530px) {
                @mixin-content;
            }
        }
        </code></pre>
        which can then be used in your css files, e.g.
        <pre><code>
        @mixin atSmall {
          font-size: 2.9rem
        }
        </code></pre>
      </li>
    </ul>

    <h2>Webpack project file structure</h2>
    <p>Using modular CSS BEM architecture</p>
    <ul>
      <li>app/</li>
      <ul>
        <li>assets/</li>
        <ul>
          <li>images/</li>
          <ul>
            <li>icons/</li>
          </ul>
          <li>scripts/</li>
          <ul>
            <li>modules/ <em>a folder containing js modules like classes, ideally each module has a single purpose like defining a class that is exported using ES6 export default or named exports and is then imported to App.js and used there.</em></li>
            <li>App.js <em>entry js file, which imports js modules from the modules scripts/modules folder e.g. <code>import MyClass from './modules/MyClass.js';</code>, and also imports the styles.css file which in turn imports all the css files e.g. <code>import '../styles/styles.css';</code></em></li>
          </ul>
          <li>styles/</li>
          <ul>
            <li>
              base/
              <em>
                a folder containing _global.css for global styles, and
                _variable.css containing css variables that can be used
                throughout all other css files, and _mixins.css for mixin definitions that can be used throughout the project
              </em>
            </li>
            <li>
              modules/
              <em>
                a folder containing css files for each block in the design under
                BEM css architecture
              </em>
            </li>
            <li>
              styles.css
              <em
                >main css file containing only @import statements to
                single-responsibility css files from base css, module css, and
                node module css (like normalize.css), e.g. <code>@import './base/_mixins.css'</code></em
              >
            </li>
          </ul>
        </ul>

        <li>bundled.js <em>file output by webpack, imports styles.css</em></li>
        <li>
          index.html <em>main html file, script tag linking to bundled.js</em>
        </li>
      </ul>

      <li>node_modules/</li>
      <li>.gitignore</li>
      <li>package-lock.json</li>
      <li>package.json</li>
      <li>webpack.config.js</li>
    </ul>

    <h2>Example App.js file for Webpack Project</h2>
    <h3>Import of styles and modules</h3>
    <p>Imports style sheet and custom modules at top.  Also importing the lazysizes npm package to be used
      for lazy loading of images.  For custom modules, often all you need to do is run the constructor
      of the imported class module.  In this case all you need to do is use new ClassModule(), so that
      the constructor runs, and you don't need to save the instance of the class to a variable, unless
      you need to use that variable later on, or as used in code-splitting.
    </p>

    <h3>Event Emitters</h3>
    <p>One powerful technique is to use the npm eventemitter package in your modules.  Then your modules
      can emit custom events, and in your App.js file, you can have methods in other modules run when those
      events are emitted.  To do this, you'll need to save your module class instances to variables so you
      can call specific methods on them as event handlers.
    </p>

    <h3>Code Splitting</h3>
    <p>Inlcudes code splitting, where modal module gets loaded only once a button is clicked.
      This saves the modal code in a variable called modal, and does not load the code again
      if the modal variable has been initialized with the code.  Import the modal module
      using the import function.  can use the webpackChunkName comment to give a name to the Additional
      js file that the browser will download once the button is clicked.  Import returns a promise,
      and must use the returned value x with new x.default() to create an instance of the module class.
      Use set timeout before running a method of the class instance if it has just been loaded to make sure 
      everything is fully loaded.
    </p>

    <code><pre>
      import '../styles/styles.css';
      import 'lazysizes'
      import MobileMenu from './modules/MobileMenu.js';

      new MobileMenu();
      let modal;

      document.querySelector('#button').addEventListener('click', e => {
        if(!modal) {
          import(/* webpackChunkName: 'modal' */ './modules/Modal.js').then((x) => {
            modal = new x.default();
            setTimeout(() => modal.openTheModal(), 20);
          }).catch(() => console.log('Error'));
        } else {
          modal.openTheModal();
        }
      })
    </pre></code>

    <h2>Example js class module for webpack project</h2>
    <p>This class would be saved in the js modules folder.  It would
      be imported into the App.js file and a variable would be initialized
      in App.js to an instance of the class.  This initialization will
      run the constructor function.
    </p>
    <code>filename: MobileMenu.js</code>
    <code>
      <pre>
        class MobileMenu {
          constructor {
            this.mobileMenu = document.querySelector('.mobile-menu');
              <em>//since the constructor runs when initialized in App.js,
                this will select the menu element in index.html
              </em>
            this.events();
          }

          events() {
            this.mobileMenu.addEventListener('click', () => this.handleClick());
            <em>//the event listener function needs to be put inside an arrow 
              function because inside an arrow function, 'this' will bind to the
              object so it can use handleClick.  Without the arrow function, 'this'
              would bind to the event target.  Arrow functions cannot bind
              'this', so 'this' takes on the value of the outer context.
            </em>
          }

          handleClick() {
            console.log('clicked!');
          }

        }
      </pre>
    </code>
  </body>
</html>
