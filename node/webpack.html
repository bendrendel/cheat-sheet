<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Webpack</title>
  </head>
  <body>
    <a href="../index.html">Home</a>

    <h1>Webpack</h1>

    <h2>Installing Webpack</h2>
    <p>
      Install webpack in a project's root directory with
      <code>npm intall webpack webpack-cli --save-dev</code> which will install
      webpack and the webpack command line interface, and the --save-dev (or -D)
      to save to devDependencies in package.json
    </p>

    <h2>Webpack Config</h2>
    <h3>Description</h3>
    <p>
      Add a file to the project's root directory called
      <code>webpack.config.js</code> to add configurations for webpack.
    </p>
    <p>
      The file should contain an exported object with the configuration
      settings, such as:
    </p>
    <ul>
      <li>
        entry property with the relative path to the file to process/bundle,
        which is the entry point to the app
      </li>
      <li>
        output property should be an object with a filename and path property,
        controlling output when webpack is run, default filename is main.js,
        default path is dist created in the project's root directory.path must
        be an absolute path, thus you'll need to use the path node core module
        which generates the absolute path of the project. e.g.
        path.resolve(__dirname, app) will save the file named filename to
        ./app/filename.
      </li>
      <li>mode property webpack will use (development, production)</li>
      <li>
        watch property if true then when you run the webpack command (through a
        package.json script) it will stay running, and rebundle with every
        change to the entry file. press ^C to stop running.
      </li>
      <li>
        module property can take an object with a rules property set to an
        array, this array can hold objects that each define how webpack should
        handle different filetypes. the objects have a test property set to a
        regex that matches the filetypes to handle, and a use property that is
        set to an array of package names that should handle that filetype. the
        example below has rules for using style-loader and css-loader, and also
        a more complex one for using postCSS-loader
      </li>
    </ul>

    <h3>Example Webpack Config</h3>
    <pre>
        <code>
        const path = require('path');

        const postCSSPlugins = [
            require('postcss-import'),
            require('postcss-simple-vars'),
            require('postcss-nested'),
            require('autoprefixer')
        ]
            
        module.exports = {
            entry: './app/assets/scripts/App.js',
            output: {
                filename: 'bundled.js',
                path: path.resolve(__dirname, 'app')
            },            
            mode: 'development',
            watch: true,
            module: {
                rules: [
                    {
                        test: /\.css$/i,
                        use: ['style-loader', 'css-loader?url=false', {
                            loader: 'postcss-loader',
                            options: {
                                postcssOptions: {
                                    plugins: postCSSPlugins
                                }
                            }
                        }]
                    }
                ]
            }
        }
        </code>
    </pre>

    <h2>Running Webpack</h2>
    <p>
      In your package.json file, add a script to run the 'webpack command such
      as
      <code>"build": "webpack"</code>
    </p>
    <p>
      run the script that runs webpack with e.g. npm run build to bundle the
      file in the entry property of the webpack config file to the output
      property of the config file. run it whenever to rebundle any changes to
      the entry file
    </p>
    <p>The output file can be linked to the index.html through a script tag</p>

    <h2>CSS Support</h2>
    <h3>Overview</h3>
    <p>
      CSS Preprocessors like SASS LESS and Stylus, and post-processors like
      PostCSS allow you to write CSS files with special features like variables,
      nested selectors, and will auto-prefix properties that need a prefix like
      moz or webkit
    </p>
    <p>
      Out of the box, webpack only bundles javascript. Additional npm packages
      are needed to support css and PostCSS
    </p>

    <h3>Supporting CSS</h3>
    <p>
      Add an import statement to the top of your 'entry' js file that imports
      the css file you want, e.g. <code>import '../styles/styles.css'</code>
    </p>
    <p>
      Use <code>npm install css-loader style-loader --save-dev</code> to install
      the css-loader package and style-loader package and add it to the dev
      dependencies, these will respectively support importing the css to your
      entry js file, and applying the styles to your html
    </p>
    <p>
      In the webpack config file, ensure to add a module: rules array object
      that tests for css files and uses style-loader and css-loader (shown in
      the example config file above)
    </p>
    <p>
      instead of 'css-loader' in the config file, use 'css-loader?url=false' to
      prevent it from handling any immages referenced in the css
    </p>

    <h3>Supporting PostCSS</h3>
    <p>
      Make sure there's an import statement in your 'entry' js file as discussed
      above
    </p>
    <p>
      Now use npm to install <code>postcss-loader</code>, similarly to above
    </p>
    <p>
      You'll also want to use npm to install the features you want, e.g
      <code
        >npm install postcss-simple-vars postcss-nested autoprefixer
        postcss-import --save-dev</code
      >
      to install variables, nested css, autoprefixing, and imports
    </p>
    <p>
      In the webpack config file add to the module rules array that tests for
      css files and use an object with a loader property and options property
      (shown in example above).
    </p>
    <ul>
      <li>
        vars can be made by declaring e.g.<code>$bluecolor: #2f557s</code> in
        the css, and then can use that var name elsewhere in css, e.g.
        <code>color: $bluecolor</code>
      </li>
      <li>
        <p>nested css can be written as in</p>
        <pre><code>
          .class { 
            .nested-class { 
              color: blue
            } 
          }
          </code></pre>
        <p>
          PostCSS will turn this into a single selector of
          <code>.class .nested-class {color: blue}</code>
        </p>
        <p>
          You can use an ampersand in the nested selectors, to make css copy the
          top classes name for more control over the final selector and avoid
          multiple classes in the final selector. E.g.
        </p>
        <pre><code>
          .block { 
            &__element { 
              color: blue
            } 
          }
          </code></pre>
        <p>Will turn into <code>.block__element {color: blue}</code></p>
      </li>
      <li>
        imports can be used by having a main css file and importing other css
        files to it, by putting <code>@import 'mymodule.css';</code> at top of
        main css file to import mymodule.css. @import is a native css feature,
        but using the postcss imports plugin will import all of the imported css
        code before going to the client, so that the client doesn't have to
        download multiple css files, which it would have to do using the native
        @import. css files to import may be named with an underscore prefix to
        indicate they are "partial files", e.g. _mymodule.css. can also import a
        node module package like normalize.css without having to specify exact
        path, e.g. @import "normalize.css" will know to find it in the node
        modules folder of the project
      </li>
    </ul>

    <h2>Webpack project file structure</h2>
    <ul>
      <li>app</li>
      <ul>
        <li>assets</li>
        <ul>
          <li>images</li>
          <ul>
            <li>icons</li>
          </ul>
          <li>scripts</li>
          <ul>
            <li>App.js <em>entry js file</em></li>
          </ul>
          <li>styles</li>
          <ul>
            <li>
              base <em>folder containing _global.css for global styles</em>
            </li>
            <li>
              modules <em>folder containing css files for each block in the
                design under BEM css architecture
              </em>
            </li>
            <li>
              styles.css
              <em
                >main css file containing only @import statements to single-
                responsibility css files from base css, module css, and node 
                module css</em
              >
            </li>
          </ul>
        </ul>

        <li>bundled.js <em>file output by webpack, imports styles.css</em></li>
        <li>
          index.html <em>main html file, script tag linking to bundled.js</em>
        </li>
      </ul>

      <li>node_modules</li>
      <li>.gitignore</li>
      <li>package-lock.json</li>
      <li>package.json</li>
      <li>webpack.config.js</li>
    </ul>
  </body>
</html>
