<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Redux</title>
</head>
<body>
    <a href="../index.html">Home</a>
    <h1>React Redux</h1>

    <h2>Basics</h2>
    <ul>
        <li>Redux is a library to help with state management in React, it is an implementation of the Flux framework, an alternative to MVC framework.  To use it in a project, install it in the root directory with <code>npm install redux</code> to install it to production dependencies</li>
        <li><strong>Basic Model: </strong> It separates React Apps into State, Views, and Actions.  Where data flows from State to View to inform what the app displays, from View to Action to inform what actions to change the state are available, and from Action to State to change the state, starting back to state to view again. </li>
        <ul>
            <li><strong>State: </strong>State defines the current data behind an application, e.g for a word processing application, the written text, the print settings, comments, etc. In redux, this could be represented by any data type in javascript that makes sense for the application, like an array, an object, etc.</li>
            <li><strong>View: </strong></li>
            <li><strong>Actions: </strong>Actions are the process of communicating data between components. When an action is generated and notifies other parts of the app it is known as dispatched. In redux, actions are represented as objects with a 'type' property, and an optional 'payload' property.  The type property describes the action such as 'todos/addTodo', 'todos/removeAll', 'todos/removeTodo'.  The payload property contains related info if relevant, like adding a todo would have a payload of a string equal to the todo, or removing a todo would contain a payload of a string equal to the todo to remove.  Removing all todos on the other hand would need no payload.  The name of the action object should be descriptive of the action, e.g. const addTodo.</li>
        </ul>
        <li><strong>Reducers: </strong>These are functions that define what actions do to the state.  It takes the state variable as a first argument, an action as a second argument, and it returns the new state, returning the state unchanged if no action or an unrecognized action is provided. It should make immutable updates (i.e. does not mutate provided arguments - note that strings, numbers, booleans are always passed by value as arguments to a function so they won't be mutated if you change them, but objects and array are passed by reference so the can be changed within the function). Also it should be a pure function meaning it should always give the same output for the same inputs. Reducers should follow the rules below, where Rule number 2 below ensures immutable updates, and 1 and 3 ensure a pure function:
        <ol>
            <li>They should only calculate the new state based on the provided state and action arguments (e.g. no global variables involved).</li>
            <li>They should not change the current state, rather make a copy, alter it, and return that as the new state (e.g. don't push to the current state, instead make a new array and use the spread operator to get the old state array elements)</li>
            <li>No side effects or asynchronous logic. (e.g. don't calculate a random number in the reducer to define the new state, rather the random number should be passed in as payload, also don't depend on any asynchronous logic to get the output because async logic could return an error or otherwise be unpredictable, async should happen outside the reducer and the results passed into the reducer as payload) </li>
        </ol> 
        Example reducer, often you'll see a default state equal to some pre-defined state variable for when the app first starts: 
        <code><pre>
                const initialState = [];
                const todoReducer = (state = initialState, action) => {
                    switch (action.type) {
                        case 'todos/addTodo': {
                            return [ ...state, action.payload];
                        }
                        case 'todos/removeAll': {
                            return [];
                        }
                        default: {
                            return state;
                        }
                    }
                }
            </pre></code></li>
        <li><strong>Store: </strong>This is a special object in Redux that houses the state, provides an initial state, provides a way to dispatch actions, and calls the reducer to updates state.  Most redux apps should have only one store. </li>
        <ul>
            <li>Use <code>import { createStore } from 'redux';</code> to get started making a store (redux must be installed with npm first in the root of the project)</li>
            <li>Now you can create <code>const store = createStore(myReducerFunction);</code> to create a store, where myReducerFunction is some reducer function typically defined above the line where you intialize the store, and where the state parameter will have a default value set to some initial state defined before the reducer.</li>
            <li><code>store.dispatch({type: 'myActionType', payload: 'myPayload'})</code> This will run the store's reducer with the provided action (where the payload is optional).  The store will save the state returned by the reducer when dispatch is called.</li>
            <li><code>store.getState()</code> will return the saved state (the most recently returned state by the reducer).  The store will initially run the reducer with default state and no action, which will return the default state and save the default state as the initial state of the store.</li>
            <li><strong>action creators</strong> are functions that return an action, e.g. <code>const toggle = () => { return {type: 'toggle'}; }</code>, and are often used in redux applications though not strictly necessary.  They would typically be defined above the reducer and initial state variables.  When an action is dispatched, you would typically use the action creator, e.g. <code>store.dispatch(toggle());</code> They may have an argument that is passed in and set as the value of the payload.</li>
            <li><code>store.subscribe(myEventListener); </code> will call the myEventListener function any time the state changes in store.  e.g. myEventListern might be a function that console logs the store.getState() value.  store.subscribe() returns a function that you can call to 'unsubscribe' myEventListener, so it stops being called in response to state changes.  Thus, you'll often see <code>const unsubscribe = store.subscribe(myListener);</code> and then you may call <code>unsubscribe()</code> later in the code to stop the event listener.  You'll often see the myEventListener function and unsubscribe const defined below the action creators, initial state, reducer, and creation of the store.</li>
            <li>The underlying implementation of store looks something like below. It accepts a reducer as an argument. It holds an internal state variable, and an array of listener functions to run.  the getState method simply returns the state.  The dispatch method accepts an action and runs the reducer with the given action and current state value, updating the state with the returned value, then for each subscribed listener function it calls the listener function since state has been updated (possibly the state didn't actually change dependign on the action).  The subscribe method accepts a listener function and adds it to the array of listeners, returning a function that will filter out the provided listener from the listener array (i.e. the unsubscribe function).  dispatch is then called to run the reducer with an empty action object, which means the initial state value will be returned be defautl and thus set the internal state value to the initial state.  Finally, createStore returns an object containing three methods: the getState, dispatch, and subscribe methods.
                <code><pre>
                    const createStore = (reducer) => {
                        let state;
                        let listeners = [];
                        
                        const getState = () => state;
                        
                        const dispatch = (action) => {
                            state = reducer(state, action);
                            listeners.forEach(listener => listener());
                        };
                        
                        const subscribe = (listener) => {
                            listeners.push(listener);
                            return () => {  
                                listeners = listeners.filter(l => l !== listener)  
                            }
                        };
                        
                        dispatch({});
                        return { getState, dispatch, subscribe };
                    }
                </pre></code>
            </li>
        </ul>
    </ul>
        
    <h2>Connecting to a UI</h2>
    <ul>
        <li>To use redux with a UI, there is a general series of steps regardless of if the UI is vanilla JS, react, or another framework</li>
        <ul>
            <li>Create a redux store</li>
            <li>Render the initial state of the store.  This involves creating a render function or some callback function that uses state to determine UI, e.g. could be as simple as having a state that is a counter and the render function sets the innerHTML of a DOM element to the value of the state variable do as to display the counter value. The render function always 1) gets the current store state, 2) select the data needed by the UI, 3) updates the UI based on the data</li>
            <li>Subscribe to updates, that is <code>store.subscribe(myRenderFunction)</code> so that the render function or other callback that updates the UI, runs everytime there is a change in the store's state, ensuring your UI is always up to date</li>
            <li>Respond to UI events by dispatching actions to the store.  e.g the on click event of a plus button has an event handler function that calls <code>store.dispatch(myActionCreator())</code> dispatching some action using an action creator, thus updating state, thus causing the subscribed render function to run, thus updating the UI.</li>
        </ul>
        <li>Used with React, connecting to the UI means the render function will be a function that calls ReactDOM.render() to render your top-level component.  After defining your render function, you then call your render function once so that the React App is rendered initially.  Then you subscribe the render function to the store, so that it runs everytime the store changes state.  Event handler methods in your react components dispatch actions to the store in order to change the state.  The state is passed in as a prop to the top level component when you render it inside the render function e.g. <code>const myRenderFunction = () => {ReactDOM.render(&ltMyTopLevelComponent state={store.getState()}/>, document.getElementById('root'))}</code></li>
        <li>Example Basic React app with Redux:
            <code><pre>
                import React from 'react';
                import ReactDOM from 'react-dom';
                import { createStore } from 'redux';

                // REDUX CODE
                ///////////////////////////////////

                const increment = () => {
                    return {type: 'increment'} 
                }

                const decrement = () => { 
                    return {type: 'decrement'}
                }

                const initialState = 0;
                const counterReducer = (state = initialState, action) => {
                    switch (action.type) {
                        case 'increment':
                            return state + 1;
                        case 'decrement':
                            return state - 1;
                        default:
                            return state; 
                    }
                } 

                const store = createStore(counterReducer);

                // REACT CODE
                ///////////////////////////////////

                const render = () => {
                    ReactDOM.render(
                        &ltCounterApp 
                            state={store.getState()}
                        />,
                        document.getElementById('root')
                    )
                }

                // Render once with the initial state.
                render();

                // Subscribe render to changes to the store's state.
                store.subscribe(render);

                function CounterApp(props) {
                    const state = props.state;
                    
                    const onIncrementButtonClicked = () => {
                        // Dispatch an 'increment' action.
                        store.dispatch(increment());
                    }
                
                    const onDecrementButtonClicked = () => {
                        // Dispatch an 'decrement' action.
                        store.dispatch(decrement());
                    }
                
                    return (   
                        &ltdiv id='counter-app'>
                            &lth1> {state} &lt/h1>
                            &ltbutton onClick={onIncrementButtonClicked}>+&lt/button> 
                            &ltbutton onClick={onDecrementButtonClicked}>-&lt/button>
                        &lt/div>
                    )
                }
            </pre></code>
        </li>
    </ul>

    <h2>Complex State</h2>
    <ul>
        <li><strong>Slices: </strong>A redux app's state will usually be an object, and each property of the object is known as a slice, with values of any data type such as a string, array, object, etc.</li>
        <li><strong>Initial State: </strong>Best practice in redux is to start the application by defineing an initialState const variable so that the structure of the state object is established, and then provide that initialState to the reducer function. Each slice should generally be set equal to an empty string, empty array, object with empty projects, false, etc.  If using reducer composition, then you would have multiple initial state const variables, one for each slice of the state, named initialSliceName.  These variables would get set to the initial value of just that slice. </li>
        <li><strong>Actions: </strong>Actions should be defined next, and each action type should be named 'slice/actiondescription', where slice is the slice changed by the action (each action should usually only effect one slice).  An action creator should be written for each action type, with an optional argument for the payload. The action creator name should be the same as the actiondescription used in the action type. Sometimes the payload will be data from an API, where perhaps the action is dispatched on app load to populate a slice that holds the data.</li>
        <li><strong>Reducer: </strong>The reducer should be defined next, with the default state set to the initial state.  It is important that it doesn't mutate the state passed to it, but makes a copy, mutates the copy and returns that, which can be tricky with complex state but the spread operator come in handy.</li>
        <ul>
            <li><strong>Reducer Composition: </strong>Also, you can use reducer composition to handle complex state.  This has one reducer called rootReducer, and this is the reducer that the store is created with, and as usual accepts a state variable and action as arguments.  The rootReducer defines a nextState const variable inside it set equal to the value of the new state to be returned by the reducer.  Each slice in the new state is set to a call to another reducer that only handles that slice, called sliceNameReducer.  The slice reducer accepts a state variable and action just like a regular reducer, but the state is just for that slice (state.sliceName) and the action is the same as the action passed to the rootReducer.  Each slice's reducer is called each time the rootReducer is called, and returns an updated slice if the action pertains to that slice or else returns the slice unchanged, then the root returns the nextState object.  Example of root reducer is below, where todosReducer and filterReducers accept their respective state slices and the action, and return an updated version of their respective state slice based on the action or return an unchanged slice if the action doesn't alter that slice.
            <code><pre>
                import { createStore } from 'redux';
 
                // todosReducer and filterReducer omitted
                
                const rootReducer = (state = {}, action) => {
                    const nextState = {
                        todos: todosReducer(state.todos, action),
                        filter: filterReducer(state.filter, action)
                    };
                    return nextState;
                };
                
                const store = createStore(rootReducer);
            </pre></code></li>
            <li><strong>combineReducers: </strong><code>combineReducers() </code>is a function that can be imported from the Redux library with e.g. <code>import { createStore, combineReducers } from 'redux';</code>.  This simplifies reducer composition.  It takes a single argument of an object whose keys are the slices of state, and the values are the functions that are the reducers for each slice.  It returns a root reducer that behaves the same as the rootReducer above.  Creation of a store with a root reducer can thus be all written inline like below, or you can create separate const reducers variable equal to the object containing the reducers, and a separate const rootReducer variable where you call the combineReducers function with it:
            <code><pre>
                const store = createStore(combineReducers({
                    todos: todosReducer,
                    filter: filterReducer
                }));
            </pre></code></li>
        </ul>
        <li><strong>Ducks File Structure: </strong>Most commonly redux apps are broken up in multiple files using the Redux Ducks pattern, shown below. src/ is a folder in your root directory, at the same level as perhaps a test/ folder and img/ folder, etc.  index.js is the entry point to the app as usual.  store.js imports redux features, and defines the root reducer and creates the store.  featureASlice.js, featureBSlice.js, etc. define the action creators, the initial state, and reducer for a single slice of state.  These files export their action creators for import into react feature components and reducers for import into store.js.  Also included are react-specific folders and files (denoted with +) that work will within the Ducks structure.  App.js is the main top level react component.  The components folder contains components that are generic and get reused in other components.  Under each features folder, the react component corresponding to rendering/updating that slice is included.  Sometimes you'll see App.js outside the app folder, directly under src.  Sometimes you'll see features as subfolder of another feature or nested even deeper if they are meant to only be rendered by that component.
        <code><pre>
            src/
            |-- index.js
            |-- app/
                |-- App.js (+)
                |-- store.js
            |-- components/
                |-- FavoriteButton.js (+)
                |-- Recipe.js (+)
            |-- features/
                |-- allRecipes/
                    |-- AllRecipes.js (+)
                    |-- allRecipesSlice.js
                |-- favoriteRecipes/
                    |-- FavoriteRecipes.js (+)
                    |-- favoriteRecipesSlice.js
                |-- searchTerm/
                    |-- SearchTerm.js (+)
                    |-- searchTermSlice.js
        </pre></code></li>
        <ul>
            <li><strong>index.js </strong>This file imports react and reactDOM, and imports App.js and store.js.  It renders App.js and passes the store state and store dispatch method to App as props.  It als renders App.js within a render function that is called once for the initial render and then subscribed to the store.
            <code><pre>
                import React from 'react';
                import ReactDOM from 'react-dom';

                import { App } from './app/App.js';
                // Import 'store' here.
                import { store } from './app/store.js';

                const render = () => {
                // Pass `state` and `dispatch` props to &ltApp />
                ReactDOM.render(
                    &ltApp 
                        state={store.getState()}
                        dispatch={store.dispatch}
                    />,
                    document.getElementById('root')
                )
                }
                render();
                // Subscribe render to changes to the `store`
                store.subscribe(render);
            </pre></code></li>
            <li><strong>App.js </strong>App.js as usual imports the feature components to render them. To these components, App.js passes as props the slice of state for that components, and the dispatch method so that the components can dispatch actions to the store. Passing state through App to the components is called prop threading or drilling and isn't ideal, this is solved with react-redux library</li>
            <li><strong>feature components: </strong>These will use the slice of state passed in as props to render the component, import action creators from the associated Slice.js file, and run the passed in dispatch method with the action creators to run in response to user actions</li>
        </ul>
    </ul>

    <h2>React-Redux</h2>
    <ul>
        <li>The react-redux library optimizes using redux with react.  It must be installed in your project's root directory with <code>npm install react-redux</code>, which installs it as a production dependency.  It offers better ways of accomplishing several things when using redux with react</li>
        <li><strong>Provider Component: </strong>This is a component in the react-redux library which you will generally import into your index.js with <code>import { Provider } from 'react-redux';</code> You will then wrap your rendered App component inside the Provider Component and pass the store as a prop to your Provider component.  This will allow the App component and all children components access to the store without having to pass it as props. e.g. index.js will render:
        <code><pre>
            ReactDOM.render(
                &ltProvider store={store}>
                    &ltApp />
                &lt/Provider>,
                document.getElementById("root")
            );
        </pre></code></li>
        <li><strong>Selectors: </strong>Selectors are functions you write in each feature's featureNameSlice.js file, which contains the action creators, initial state, and reducer for one slice of state.  There is nothing to import from react-redux to implement these, they just use vanilla js. The selector functions take the full state as an argument (i.e. all slices of state) and return just one slice of state, or perhaps some sub part of that slice, or filter the slice first, etc.  They should deal with the slice in the slice.js file they are in.  They need to be pure functions that do not mutate the argument, and always provide the same output for same input with no randomness or side effects.  They should be named selectDescriptionOfDataReturned, e.g. selectAllRecipes or selectFilteredRecipes.  They should be exported so they are available for import where needed, in other slice files or UI components.  They can be as simple as returned a slice of state, e.g. <code>export const selectFilter = state => state.filter;</code> or more complicated like returning only the todo items in the state.todos array that are marked as complete or filtering state.AllRecipes array in the allRecipesSlice.js file based on state.searchTerm that is retrieved by importing selectSearchTerm from the searchTermSlice.js file:
        <code>
            <pre>
                export const selectIsCompleteIDs = state => state.todos.filter(
                    todo => todo.isComplete).map(todo => todo.id)
            </pre>
        </code>
        <code>
            <pre>
                export const selectFilteredAllRecipes = (state) => {
                    const allRecipes = selectAllRecipes(state);
                    const searchTerm = selectSearchTerm(state);

                    return allRecipes.filter(recipe => recipe.name.toLowerCase().includes(searchTerm.toLowerCase()));
                }
            </pre>
        </code>
    </li>
    <li><strong>useSelector: </strong>This method is provided by react-redux for use in React components and must be imported in the component with <code>import { useSelector } from 'react-redux';</code> You'll also need to import selector functions from one or more slice.js files to use the selectors.  You use useSelector in a component definition (inside the component class definition or function definition of function components), providing it an argument of a selector.  useSelector must be used within a child component under the top level Provider component.  It will feed the selector the current state of the store, and return whatever the selector returns.  However, it will also subscribe rendering of the component to the store, but only for changes to the slices involved in the selector function.  So, components will re-render only when slices update that effect them.  You don't have to use a separately defined selector function with useSelector, and can instead define the selector in line with useSelector, e.g. <code>const todos = useSelector(state => state.todos);</code> or could use props passed to the component in the selector e.g. <code>const todo = useSelector(state => state.todos[props.id])</code></li>
    <li><strong>useDispatch: </strong>This method is provided by react-redux for use in React components and must be imported in the component with (also importing useSelector in this example) <code>import { useSelector, useDispatch } from 'react-redux';</code>.  This method simply returns the store's dispatch method, so that you can use dispatch in your component without having to pass it down through props (from index.js to App.js to the component).  In your component definition (inside your component class body or function body for function components), you would include <code>const dispatch = useDispatch()</code>.  Then you can use dispatch like normal, e.g. in response to a button click you might use <code>dispatch(removeTodo(todo))</code>, where removeTodo is an action creator that you imported at the beginning of the component file from the appropriate slice file, and this action creator happens to take an argument that it uses as payload to determine which todo should be removed.</li>
    </ul>

    <h2>Redux Toolkit</h2>
    <ul>
        <li>The redux toolkit (RTK) is a library that helps reduce some of the code you have to write to use redux.  It needs to be installed in the root of a project with <code>npm install @reduxjs/toolkit</code></li>
        <li><strong>createSlice() </strong>This is a method available in the redux toolkit and needs to be imported to the file using it with <code>import { createSlice } from '@reduxjs/toolkit';</code> It provides a way of more easily defining a slice reducer and associated action creators.</li>
        <ul>
            <li>createSlice accepts an object argument with three properties: name, initialState, and reducers.  This object may be defined first as a const called 'options' and provided to the createSlice() method.  The name property should be a string that is the name of the slice and the prefix used in the action types for the slice (e.g. todos is the prefix in todos/addTodo).  The initialState property is the initial state value for that slice.  The reducers property is an object with keys equal to the last half of each action type (e.g. addTodo). Each key is set to a function called case reducers that accept state and action arguments and returns the new state for that action. It is not necessary to define a default action.</li>
            <li>createSlice returns an object with three properties: name, reducer, and actions, and which you normally would save to a const named nameSlice (e.g. todoSlice).  The name is the name you provide in the options object. The reducer is an automatically generated slice reducer function that essentially creates a traditional switch statement with the code you provided for each possible action in the options object, along with a default case that returns the state unchanged.  Finally, the actions property is an object whose keys are the names of the actions you provided in the options object (e.g. addTodo), and each key is set to an action creator function that accepts a payload argument and returns an action object of type name/action (e.g. todos/addTodo) and the payload provided.  You will want to export the action creators so they can be used elsewhere.  This is most commonly done with e.g. <code>export const { addTodo, toggleTodo } = todosSlice.actions;</code> where todosSlice is the name of the const you save the return value of createSlice.  You'll also want to export the reducer function so that it can be imported into the store to create the combined reducer, this is typically made to be the default export, e.g <code>export default todosSlice.reducer;</code></li>
            <li>createSlice also has the benefit that it uses the Immer library to allow you to write mutative code without actually mutating the provided arguments, so you don't have to worry about writing an immutable function, and can mutate the passed in state argument for easier code (e.g. you can push to a state that is an array).</li>
            <li>Example createSlice:
                <code><pre>
                    const todosSlice = createSlice({
                        name: 'todos',
                        initialState: [],
                        reducers: {
                            addTodo(state, action) {
                                const { id, text } = action.payload
                                state.push({ id, text, completed: false })
                            },
                            toggleTodo(state, action) {
                                const todo = state.find(todo => todo.id === action.payload)
                                if (todo) {
                                    todo.completed = !todo.completed
                                }
                            }
                        }
                    })
                        
                    /* Object returned by todosSlice */
                    {
                        name: 'todos',
                        reducer: (state, action) => newState,
                        actions: {
                            addTodo: (payload) => ({type: 'todos/addTodo', payload}),
                            toggleTodo: (payload) => ({type: 'todos/toggleTodo', payload})
                        },
                        // case reducers field omitted
                    }
                </pre></code>
            </li>
        </ul>
        <li><strong>configureStore() </strong>This is a method provided by redux toolkit that you would import into your store.js file with <code>import { configureStore } from '@reduxjs/toolkit';</code>.  It is passed a configuration object and it returns a store object that you would save to your const store, in place of create store.  The config object can have multiple properties but the most basic usage is a single property called reducer.  reducer is set equal to an object that has keys equal to the name of each slice of state, and values of the associated slice Reducer, which would be imported as usual in to the store.js file.  This reducer object is the same thing you would pass to combineReducers to create a root reducer.  Passing this config object to configureStore() will create a root reducer and create a store based on that root reducer, thus making the process a little simpler than combineReducers and createStore (which you don't have to import if you're using configureStore instead).  However, configureStore will also add middleware and set up Redux Dev Tools extension, thus saving you even more code. Example usage in a store.js file:
        <code><pre>
            import { configureStore } from '@reduxjs/toolkit'
 
            import todosReducer from './features/todos/todosSlice'
            import filtersReducer from './features/filters/filtersSlice'
            
            const store = configureStore({
                reducer: {
                    // Define a top-level state field named `todos`, handled by `todosReducer`
                    todos: todosReducer,
                    filters: filtersReducer
                }
            });
            
            export default store
        </pre></code></li>
    </ul>
</body>
</html>