<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Redux</title>
</head>
<body>
    <a href="../index.html">Home</a>
    <h1>React Redux</h1>

    <h2>Basics</h2>
    <ul>
        <li>Redux is a library to help with state management in React, it is an implementation of the Flux framework, an alternative to MVC framework.  To use it in a project, install it in the root directory with <code>npm install redux</code> to install it to production dependencies</li>
        <li><strong>Basic Model: </strong> It separates React Apps into State, Views, and Actions.  Where data flows from State to View to inform what the app displays, from View to Action to inform what actions to change the state are available, and from Action to State to change the state, starting back to state to view again. </li>
        <ul>
            <li><strong>State: </strong>State defines the current data behind an application, e.g for a word processing application, the written text, the print settings, comments, etc. In redux, this could be represented by any data type in javascript that makes sense for the application, like an array, an object, etc.</li>
            <li><strong>View: </strong></li>
            <li><strong>Actions: </strong>Actions are the process of communicating data between components. When an action is generated and notifies other parts of the app it is known as dispatched. In redux, actions are represented as objects with a 'type' property, and an optional 'payload' property.  The type property describes the action such as 'todos/addTodo', 'todos/removeAll', 'todos/removeTodo'.  The payload property contains related info if relevant, like adding a todo would have a payload of a string equal to the todo, or removing a todo would contain a payload of a string equal to the todo to remove.  Removing all todos on the other hand would need no payload.  The name of the action object should be descriptive of the action, e.g. const addTodo.</li>
        </ul>
        <li><strong>Reducers: </strong>These are functions that define what actions do to the state.  It takes the state variable as a first argument, an action as a second argument, and it returns the new state, returning the state unchanged if no action or an unrecognized action is provided. It should make immutable updates (i.e. does not mutate provided arguments - note that strings, numbers, booleans are always passed by value as arguments to a function so they won't be mutated if you change them, but objects and array are passed by reference so the can be changed within the function). Also it should be a pure function meaning it should always give the same output for the same inputs. Reducers should follow the rules below, where Rule number 2 below ensures immutable updates, and 1 and 3 ensure a pure function:
        <ol>
            <li>They should only calculate the new state based on the provided state and action arguments (e.g. no global variables involved).</li>
            <li>They should not change the current state, rather make a copy, alter it, and return that as the new state (e.g. don't push to the current state, instead make a new array and use the spread operator to get the old state array elements)</li>
            <li>No side effects or asynchronous logic. (e.g. don't calculate a random number in the reducer to define the new state, rather the random number should be passed in as payload, also don't depend on any asynchronous logic to get the output because async logic could return an error or otherwise be unpredictable, async should happen outside the reducer and the results passed into the reducer as payload) </li>
        </ol> 
        Example reducer, often you'll see a default state equal to some pre-defined state variable for when the app first starts: 
        <code><pre>
                const initialState = [];
                const todoReducer = (state = initialState, action) => {
                    switch (action.type) {
                        case 'todos/addTodo': {
                            return [ ...state, action.payload];
                        }
                        case 'todos/removeAll': {
                            return [];
                        }
                        default: {
                            return state;
                        }
                    }
                }
            </pre></code></li>
        <li><strong>Store: </strong>This is a special object in Redux that houses the state, provides an initial state, provides a way to dispatch actions, and calls the reducer to updates state.  Most redux apps should have only one store. </li>
        <ul>
            <li>Use <code>import { createStore } from 'redux';</code> to get started making a store (redux must be installed with npm first in the root of the project)</li>
            <li>Now you can create <code>const store = createStore(myReducerFunction);</code> to create a store, where myReducerFunction is some reducer function typically defined above the line where you intialize the store, and where the state parameter will have a default value set to some initial state defined before the reducer.</li>
            <li><code>store.dispatch({type: 'myActionType', payload: 'myPayload'})</code> This will run the store's reducer with the provided action (where the payload is optional).  The store will save the state returned by the reducer when dispatch is called.</li>
            <li><code>store.getState()</code> will return the saved state (the most recently returned state by the reducer).  The store will initially run the reducer with default state and no action, which will return the default state and save the default state as the initial state of the store.</li>
            <li><strong>action creators</strong> are functions that return an action, e.g. <code>const toggle = () => { return {type: 'toggle'}; }</code>, and are often used in redux applications though not strictly necessary.  They would typically be defined above the reducer and initial state variables.  When an action is dispatched, you would typically use the action creator, e.g. <code>store.dispatch(toggle());</code> They may have an argument that is passed in and set as the value of the payload.</li>
            <li><code>store.subscribe(myEventListener); </code> will call the myEventListener function any time the state changes in store.  e.g. myEventListern might be a function that console logs the store.getState() value.  store.subscribe() returns a function that you can call to 'unsubscribe' myEventListener, so it stops being called in response to state changes.  Thus, you'll often see <code>const unsubscribe = store.subscribe(myListener);</code> and then you may call <code>unsubscribe()</code> later in the code to stop the event listener.  You'll often see the myEventListener function and unsubscribe const defined below the action creators, initial state, reducer, and creation of the store.</li>
        </ul>
    </ul>
        
    <h2>Connecting to a UI</h2>
    <ul>
        <li>To use redux with a UI, there is a general series of steps regardless of if the UI is vanilla JS, react, or another framework</li>
        <ul>
            <li>Create a redux store</li>
            <li>Render the initial state of the store.  This involves creating a render function or some callback function that uses state to determine UI, e.g. could be as simple as having a state that is a counter and the render function sets the innerHTML of a DOM element to the value of the state variable do as to display the counter value. The render function always 1) gets the current store state, 2) select the data needed by the UI, 3) updates the UI based on the data</li>
            <li>Subscribe to updates, that is <code>store.subscribe(myRenderFunction)</code> so that the render function or other callback that updates the UI, runs everytime there is a change in the store's state, ensuring your UI is always up to date</li>
            <li>Respond to UI events by dispatching actions to the store.  e.g the on click event of a plus button has an event handler function that calls <code>store.dispatch(myActionCreator())</code> dispatching some action using an action creator, thus updating state, thus causing the subscribed render function to run, thus updating the UI.</li>
        </ul>
        <li>Used with React, connecting to the UI means the render function will be a function that calls ReactDOM.render() to render your top-level component.  After defining your render function, you then call your render function once so that the React App is rendered initially.  Then you subscribe the render function to the store, so that it runs everytime the store changes state.  Event handler methods in your react components dispatch actions to the store in order to change the state.  The state is passed in as a prop to the top level component when you render it inside the render function e.g. <code>const myRenderFunction = () => {ReactDOM.render(&ltMyTopLevelComponent state={store.getState()}/>, document.getElementById('root'))}</code></li>
        <li>Example Basic React app with Redux:
            <code><pre>
                import React from 'react';
                import ReactDOM from 'react-dom';
                import { createStore } from 'redux';

                // REDUX CODE
                ///////////////////////////////////

                const increment = () => {
                    return {type: 'increment'} 
                }

                const decrement = () => { 
                    return {type: 'decrement'}
                }

                const initialState = 0;
                const counterReducer = (state = initialState, action) => {
                    switch (action.type) {
                        case 'increment':
                            return state + 1;
                        case 'decrement':
                            return state - 1;
                        default:
                            return state; 
                    }
                } 

                const store = createStore(counterReducer);

                // REACT CODE
                ///////////////////////////////////

                const render = () => {
                    ReactDOM.render(
                        &ltCounterApp 
                            state={store.getState()}
                        />,
                        document.getElementById('root')
                    )
                }

                // Render once with the initial state.
                render();

                // Subscribe render to changes to the store's state.
                store.subscribe(render);

                function CounterApp(props) {
                    const state = props.state;
                    
                    const onIncrementButtonClicked = () => {
                        // Dispatch an 'increment' action.
                        store.dispatch(increment());
                    }
                
                    const onDecrementButtonClicked = () => {
                        // Dispatch an 'decrement' action.
                        store.dispatch(decrement());
                    }
                
                    return (   
                        &ltdiv id='counter-app'>
                            &lth1> {state} &lt/h1>
                            &ltbutton onClick={onIncrementButtonClicked}>+&lt/button> 
                            &ltbutton onClick={onDecrementButtonClicked}>-&lt/button>
                        &lt/div>
                    )
                }
            </pre></code>
        </li>
    </ul>

    <h2>Complex State</h2>
    <ul>
        <li><strong>Slices: </strong>A redux app's state will usually be an object, and each property of the object is known as a slice, with values of any data type such as a string, array, object, etc.</li>
        <li><strong>Initial State: </strong>Best practice in redux is to start the application by defineing an initialState const variable so that the structure of the state object is established, and then provide that initialState to the reducer function. Each slice should generally be set equal to an empty string, empty array, object with empty projects, false, etc.  If using reducer composition, then you would have multiple initial state const variables, one for each slice of the state, named initialSliceName.  These variables would get set to the initial value of just that slice. </li>
        <li><strong>Actions: </strong>Actions should be defined next, and each action type should be named 'slice/actiondescription', where slice is the slice changed by the action (each action should usually only effect one slice).  An action creator should be written for each action type, with an optional argument for the payload. The action creator name should be the same as the actiondescription used in the action type. Sometimes the payload will be data from an API, where perhaps the action is dispatched on app load to populate a slice that holds the data.</li>
        <li><strong>Reducer: </strong>The reducer should be defined next, with the default state set to the initial state.  It is important that it doesn't mutate the state passed to it, but makes a copy, mutates the copy and returns that, which can be tricky with complex state but the spread operator come in handy.</li>
        <ul>
            <li><strong>Reducer Composition: </strong>Also, you can use reducer composition to handle complex state.  This has one reducer called rootReducer, and this is the reducer that the store is created with, and as usual accepts a state variable and action as arguments.  The rootReducer defines a nextState const variable inside it set equal to the value of the new state to be returned by the reducer.  Each slice in the new state is set to a call to another reducer that only handles that slice, called sliceNameReducer.  The slice reducer accepts a state variable and action just like a regular reducer, but the state is just for that slice (state.sliceName) and the action is the same as the action passed to the rootReducer.  Each slice's reducer is called each time the rootReducer is called, and returns an updated slice if the action pertains to that slice or else returns the slice unchanged, then the root returns the nextState object.  Example of root reducer is below, where todosReducer and filterReducers accept their respective state slices and the action, and return an updated version of their respective state slice based on the action or return an unchanged slice if the action doesn't alter that slice.
            <code><pre>
                import { createStore } from 'redux';
 
                // todosReducer and filterReducer omitted
                
                const rootReducer = (state = {}, action) => {
                    const nextState = {
                        todos: todosReducer(state.todos, action),
                        filter: filterReducer(state.filter, action)
                    };
                    return nextState;
                };
                
                const store = createStore(rootReducer);
            </pre></code></li>
            <li><strong>combineReducers: </strong><code>combineReducers() </code>is a function that can be imported from the Redux library with e.g. <code>import { createStore, combineReducers } from 'redux';</code>.  This simplifies reducer composition.  It takes a single argument of an object whose keys are the slices of state, and the values are the functions that are the reducers for each slice.  It returns a root reducer that behaves the same as the rootReducer above.  Creation of a store with a root reducer can thus be all written inline like below, or you can create separate const reducers variable equal to the object containing the reducers, and a separate const rootReducer variable where you call the combineReducers function with it:
            <code><pre>
                const store = createStore(combineReducers({
                    todos: todosReducer,
                    filter: filterReducer
                }));
            </pre></code></li>
        </ul>
        <li><strong>Ducks File Structure: </strong>Most commonly redux apps are broken up in multiple files using the Redux Ducks pattern, shown below. src/ is a folder in your root directory, at the same level as perhaps a test/ folder and img/ folder, etc.  index.js is the entry point to the app as usual.  store.js imports redux features, and defines the root reducer and creates the store.  featureASlice.js, featureBSlice.js, etc. define the action creators, the initial state, and reducer for a single slice of state.  These files export their action creators for import into react feature components and reducers for import into store.js.  Also included are react-specific folders and files (denoted with +) that work will within the Ducks structure.  App.js is the main top level react component.  The components folder contains components that are generic and get reused in other components.  Under each features folder, the react component corresponding to rendering/updating that slice is included.
        <code><pre>
            src/
            |-- index.js
            |-- app/
                |-- App.js (+)
                |-- store.js
            |-- components/
                |-- FavoriteButton.js (+)
                |-- Recipe.js (+)
            |-- features/
                |-- allRecipes/
                    |-- AllRecipes.js (+)
                    |-- allRecipesSlice.js
                |-- favoriteRecipes/
                    |-- FavoriteRecipes.js (+)
                    |-- favoriteRecipesSlice.js
                |-- searchTerm/
                    |-- SearchTerm.js (+)
                    |-- searchTermSlice.js
        </pre></code></li>
        <ul>
            <li><strong>index.js </strong>This file imports react and reactDOM, and imports App.js and store.js.  It renders App.js and passes the store state and store dispatch method to App as props.  It als renders App.js within a render function that is called once for the initial render and then subscribed to the store.
            <code><pre>
                import React from 'react';
                import ReactDOM from 'react-dom';

                import { App } from './app/App.js';
                // Import 'store' here.
                import { store } from './app/store.js';

                const render = () => {
                // Pass `state` and `dispatch` props to &ltApp />
                ReactDOM.render(
                    &ltApp 
                        state={store.getState()}
                        dispatch={store.dispatch}
                    />,
                    document.getElementById('root')
                )
                }
                render();
                // Subscribe render to changes to the `store`
                store.subscribe(render);
            </pre></code></li>
            <li><strong>App.js </strong>App.js as usual imports the feature components to render them. To these components, App.js passes as props the slice of state for that components, and the dispatch method so that the components can dispatch actions to the store. Passing state through App to the components is called prop threading or drilling and isn't ideal, this is solved with react-redux library</li>
            <li><strong>feature components: </strong>These will use the slice of state passed in as props to render the component, import action creators from the associated Slice.js file, and run the passed in dispatch method with the action creators to run in response to user actions</li>
        </ul>
    </ul>
</body>
</html>