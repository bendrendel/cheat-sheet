<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Redux</title>
</head>
<body>
    <a href="../index.html">Home</a>
    <h1>React Redux</h1>

    <h2>Basics</h2>
    <ul>
        <li>Redux is a library to help with state management in React, it is an implementation of the Flux framework, an alternative to MVC framework.  To use it in a project, install it in the root directory with <code>npm install redux</code> to install it to production dependencies</li>
        <li>You can use <code>npx create-react-app my-app --template redux --use-npm</code> to start a react app with a redux template called my-app.  The --use-npm flag ensure npm will be used instead of yarn (which it will use by default if yarn is installed on your computer) which can cause errors when using the redux template.  The template will set up an app folder under src with a store, and a feature folder.  It uses redux toolkit so the store is set up using configureStore.</li>
        <li><strong>Basic Model: </strong> It separates React Apps into State, Views, and Actions.  Where data flows from State to View to inform what the app displays, from View to Action to inform what actions to change the state are available, and from Action to State to change the state, starting back to state to view again. </li>
        <ul>
            <li><strong>State: </strong>State defines the current data behind an application, e.g for a word processing application, the written text, the print settings, comments, etc. In redux, this could be represented by any data type in javascript that makes sense for the application, like an array, an object, etc.</li>
            <li><strong>View: </strong></li>
            <li><strong>Actions: </strong>Actions are the process of communicating data between components. When an action is generated and notifies other parts of the app it is known as dispatched. In redux, actions are represented as objects with a 'type' property, and an optional 'payload' property.  The type property describes the action such as 'todos/addTodo', 'todos/removeAll', 'todos/removeTodo'.  The payload property contains related info if relevant, like adding a todo would have a payload of a string equal to the todo, or removing a todo would contain a payload of a string equal to the todo to remove.  Removing all todos on the other hand would need no payload.  The name of the action object should be descriptive of the action, e.g. const addTodo.</li>
        </ul>
        <li><strong>Reducers: </strong>These are functions that define what actions do to the state.  It takes the state variable as a first argument, an action as a second argument, and it returns the new state, returning the state unchanged if no action or an unrecognized action is provided. It should make immutable updates (i.e. does not mutate provided arguments - note that strings, numbers, booleans are always passed by value as arguments to a function so they won't be mutated if you change them, but objects and array are passed by reference so the can be changed within the function). Also it should be a pure function meaning it should always give the same output for the same inputs. Reducers should follow the rules below, where Rule number 2 below ensures immutable updates, and 1 and 3 ensure a pure function:
        <ol>
            <li>They should only calculate the new state based on the provided state and action arguments (e.g. no global variables involved).</li>
            <li>They should not change the current state, rather make a copy, alter it, and return that as the new state (e.g. don't push to the current state, instead make a new array and use the spread operator to get the old state array elements)</li>
            <li>No side effects or asynchronous logic. (e.g. don't calculate a random number in the reducer to define the new state, rather the random number should be passed in as payload, also don't depend on any asynchronous logic to get the output because async logic could return an error or otherwise be unpredictable, async should happen outside the reducer and the results passed into the reducer as payload) </li>
        </ol> 
        Example reducer, often you'll see a default state equal to some pre-defined state variable for when the app first starts: 
        <code><pre>
                const initialState = [];
                const todoReducer = (state = initialState, action) => {
                    switch (action.type) {
                        case 'todos/addTodo': {
                            return [ ...state, action.payload];
                        }
                        case 'todos/removeAll': {
                            return [];
                        }
                        default: {
                            return state;
                        }
                    }
                }
            </pre></code></li>
        <li><strong>Store: </strong>This is a special object in Redux that houses the state, provides an initial state, provides a way to dispatch actions, and calls the reducer to updates state.  Most redux apps should have only one store. </li>
        <ul>
            <li>Use <code>import { createStore } from 'redux';</code> to get started making a store (redux must be installed with npm first in the root of the project)</li>
            <li>Now you can create <code>const store = createStore(myReducerFunction);</code> to create a store, where myReducerFunction is some reducer function typically defined above the line where you intialize the store, and where the state parameter will have a default value set to some initial state defined before the reducer.</li>
            <li><code>store.dispatch({type: 'myActionType', payload: 'myPayload'})</code> This will run the store's reducer with the provided action (where the payload is optional).  The store will save the state returned by the reducer when dispatch is called.</li>
            <li><code>store.getState()</code> will return the saved state (the most recently returned state by the reducer).  The store will initially run the reducer with default state and no action, which will return the default state and save the default state as the initial state of the store.</li>
            <li><strong>action creators</strong> are functions that return an action, e.g. <code>const toggle = () => { return {type: 'toggle'}; }</code>, and are often used in redux applications though not strictly necessary.  They would typically be defined above the reducer and initial state variables.  When an action is dispatched, you would typically use the action creator, e.g. <code>store.dispatch(toggle());</code> They may have an argument that is passed in and set as the value of the payload.</li>
            <li><code>store.subscribe(myEventListener); </code> will call the myEventListener function any time the state changes in store.  e.g. myEventListern might be a function that console logs the store.getState() value.  store.subscribe() returns a function that you can call to 'unsubscribe' myEventListener, so it stops being called in response to state changes.  Thus, you'll often see <code>const unsubscribe = store.subscribe(myListener);</code> and then you may call <code>unsubscribe()</code> later in the code to stop the event listener.  You'll often see the myEventListener function and unsubscribe const defined below the action creators, initial state, reducer, and creation of the store.</li>
            <li>The underlying implementation of store looks something like below. It accepts a reducer as an argument. It holds an internal state variable, and an array of listener functions to run.  the getState method simply returns the state.  The dispatch method accepts an action and runs the reducer with the given action and current state value, updating the state with the returned value, then for each subscribed listener function it calls the listener function since state has been updated (possibly the state didn't actually change dependign on the action).  The subscribe method accepts a listener function and adds it to the array of listeners, returning a function that will filter out the provided listener from the listener array (i.e. the unsubscribe function).  dispatch is then called to run the reducer with an empty action object, which means the initial state value will be returned be defautl and thus set the internal state value to the initial state.  Finally, createStore returns an object containing three methods: the getState, dispatch, and subscribe methods.
                <code><pre>
                    const createStore = (reducer) => {
                        let state;
                        let listeners = [];
                        
                        const getState = () => state;
                        
                        const dispatch = (action) => {
                            state = reducer(state, action);
                            listeners.forEach(listener => listener());
                        };
                        
                        const subscribe = (listener) => {
                            listeners.push(listener);
                            return () => {  
                                listeners = listeners.filter(l => l !== listener)  
                            }
                        };
                        
                        dispatch({});
                        return { getState, dispatch, subscribe };
                    }
                </pre></code>
            </li>
        </ul>
    </ul>
        
    <h2>Connecting to a UI</h2>
    <ul>
        <li>To use redux with a UI, there is a general series of steps regardless of if the UI is vanilla JS, react, or another framework</li>
        <ul>
            <li>Create a redux store</li>
            <li>Render the initial state of the store.  This involves creating a render function or some callback function that uses state to determine UI, e.g. could be as simple as having a state that is a counter and the render function sets the innerHTML of a DOM element to the value of the state variable do as to display the counter value. The render function always 1) gets the current store state, 2) select the data needed by the UI, 3) updates the UI based on the data</li>
            <li>Subscribe to updates, that is <code>store.subscribe(myRenderFunction)</code> so that the render function or other callback that updates the UI, runs everytime there is a change in the store's state, ensuring your UI is always up to date</li>
            <li>Respond to UI events by dispatching actions to the store.  e.g the on click event of a plus button has an event handler function that calls <code>store.dispatch(myActionCreator())</code> dispatching some action using an action creator, thus updating state, thus causing the subscribed render function to run, thus updating the UI.</li>
        </ul>
        <li>Used with React, connecting to the UI means the render function will be a function that calls ReactDOM.render() to render your top-level component.  After defining your render function, you then call your render function once so that the React App is rendered initially.  Then you subscribe the render function to the store, so that it runs everytime the store changes state.  Event handler methods in your react components dispatch actions to the store in order to change the state.  The state is passed in as a prop to the top level component when you render it inside the render function e.g. <code>const myRenderFunction = () => {ReactDOM.render(&ltMyTopLevelComponent state={store.getState()}/>, document.getElementById('root'))}</code></li>
        <li>Example Basic React app with Redux:
            <code><pre>
                import React from 'react';
                import ReactDOM from 'react-dom';
                import { createStore } from 'redux';

                // REDUX CODE
                ///////////////////////////////////

                const increment = () => {
                    return {type: 'increment'} 
                }

                const decrement = () => { 
                    return {type: 'decrement'}
                }

                const initialState = 0;
                const counterReducer = (state = initialState, action) => {
                    switch (action.type) {
                        case 'increment':
                            return state + 1;
                        case 'decrement':
                            return state - 1;
                        default:
                            return state; 
                    }
                } 

                const store = createStore(counterReducer);

                // REACT CODE
                ///////////////////////////////////

                const render = () => {
                    ReactDOM.render(
                        &ltCounterApp 
                            state={store.getState()}
                        />,
                        document.getElementById('root')
                    )
                }

                // Render once with the initial state.
                render();

                // Subscribe render to changes to the store's state.
                store.subscribe(render);

                function CounterApp(props) {
                    const state = props.state;
                    
                    const onIncrementButtonClicked = () => {
                        // Dispatch an 'increment' action.
                        store.dispatch(increment());
                    }
                
                    const onDecrementButtonClicked = () => {
                        // Dispatch an 'decrement' action.
                        store.dispatch(decrement());
                    }
                
                    return (   
                        &ltdiv id='counter-app'>
                            &lth1> {state} &lt/h1>
                            &ltbutton onClick={onIncrementButtonClicked}>+&lt/button> 
                            &ltbutton onClick={onDecrementButtonClicked}>-&lt/button>
                        &lt/div>
                    )
                }
            </pre></code>
        </li>
    </ul>

    <h2>Complex State</h2>
    <ul>
        <li><strong>Slices: </strong>A redux app's state will usually be an object, and each property of the object is known as a slice, with values of any data type such as a string, array, object, etc.</li>
        <li><strong>Initial State: </strong>Best practice in redux is to start the application by defineing an initialState const variable so that the structure of the state object is established, and then provide that initialState to the reducer function. Each slice should generally be set equal to an empty string, empty array, object with empty projects, false, etc.  If using reducer composition, then you would have multiple initial state const variables, one for each slice of the state, named initialSliceName.  These variables would get set to the initial value of just that slice. </li>
        <li><strong>Actions: </strong>Actions should be defined next, and each action type should be named 'slice/actiondescription', where slice is the slice changed by the action (each action should usually only effect one slice).  An action creator should be written for each action type, with an optional argument for the payload. The action creator name should be the same as the actiondescription used in the action type. Sometimes the payload will be data from an API, where perhaps the action is dispatched on app load to populate a slice that holds the data.</li>
        <li><strong>Reducer: </strong>The reducer should be defined next, with the default state set to the initial state.  It is important that it doesn't mutate the state passed to it, but makes a copy, mutates the copy and returns that, which can be tricky with complex state but the spread operator come in handy.</li>
        <ul>
            <li><strong>Reducer Composition: </strong>Also, you can use reducer composition to handle complex state.  This has one reducer called rootReducer, and this is the reducer that the store is created with, and as usual accepts a state variable and action as arguments.  The rootReducer defines a nextState const variable inside it set equal to the value of the new state to be returned by the reducer.  Each slice in the new state is set to a call to another reducer that only handles that slice, called sliceNameReducer.  The slice reducer accepts a state variable and action just like a regular reducer, but the state is just for that slice (state.sliceName) and the action is the same as the action passed to the rootReducer.  Each slice's reducer is called each time the rootReducer is called, and returns an updated slice if the action pertains to that slice or else returns the slice unchanged, then the root returns the nextState object.  Example of root reducer is below, where todosReducer and filterReducers accept their respective state slices and the action, and return an updated version of their respective state slice based on the action or return an unchanged slice if the action doesn't alter that slice.
            <code><pre>
                import { createStore } from 'redux';
 
                // todosReducer and filterReducer omitted
                
                const rootReducer = (state = {}, action) => {
                    const nextState = {
                        todos: todosReducer(state.todos, action),
                        filter: filterReducer(state.filter, action)
                    };
                    return nextState;
                };
                
                const store = createStore(rootReducer);
            </pre></code></li>
            <li><strong>combineReducers: </strong><code>combineReducers() </code>is a function that can be imported from the Redux library with e.g. <code>import { createStore, combineReducers } from 'redux';</code>.  This simplifies reducer composition.  It takes a single argument of an object whose keys are the slices of state, and the values are the functions that are the reducers for each slice.  It returns a root reducer that behaves the same as the rootReducer above.  Creation of a store with a root reducer can thus be all written inline like below, or you can create separate const reducers variable equal to the object containing the reducers, and a separate const rootReducer variable where you call the combineReducers function with it:
            <code><pre>
                const store = createStore(combineReducers({
                    todos: todosReducer,
                    filter: filterReducer
                }));
            </pre></code></li>
        </ul>
        <li><strong>Ducks File Structure: </strong>Most commonly redux apps are broken up in multiple files using the Redux Ducks pattern, shown below. src/ is a folder in your root directory, at the same level as perhaps a test/ folder and img/ folder, etc.  index.js is the entry point to the app as usual.  store.js imports redux features, and defines the root reducer and creates the store.  featureASlice.js, featureBSlice.js, etc. define the action creators, the initial state, and reducer for a single slice of state.  These files export their action creators for import into react feature components and reducers for import into store.js.  Also included are react-specific folders and files (denoted with +) that work will within the Ducks structure.  App.js is the main top level react component.  The components folder contains components that are generic and get reused in other components.  Under each features folder, the react component corresponding to rendering/updating that slice is included.  Sometimes you'll see App.js outside the app folder, directly under src.  Sometimes you'll see features as subfolder of another feature or nested even deeper if they are meant to only be rendered by that component.
        <code><pre>
            src/
            |-- index.js
            |-- app/
                |-- App.js (+)
                |-- store.js
            |-- components/
                |-- FavoriteButton.js (+)
                |-- Recipe.js (+)
            |-- features/
                |-- allRecipes/
                    |-- AllRecipes.js (+)
                    |-- allRecipesSlice.js
                |-- favoriteRecipes/
                    |-- FavoriteRecipes.js (+)
                    |-- favoriteRecipesSlice.js
                |-- searchTerm/
                    |-- SearchTerm.js (+)
                    |-- searchTermSlice.js
        </pre></code></li>
        <ul>
            <li><strong>index.js </strong>This file imports react and reactDOM, and imports App.js and store.js.  It renders App.js and passes the store state and store dispatch method to App as props.  It als renders App.js within a render function that is called once for the initial render and then subscribed to the store.
            <code><pre>
                import React from 'react';
                import ReactDOM from 'react-dom';

                import { App } from './app/App.js';
                // Import 'store' here.
                import { store } from './app/store.js';

                const render = () => {
                // Pass `state` and `dispatch` props to &ltApp />
                ReactDOM.render(
                    &ltApp 
                        state={store.getState()}
                        dispatch={store.dispatch}
                    />,
                    document.getElementById('root')
                )
                }
                render();
                // Subscribe render to changes to the `store`
                store.subscribe(render);
            </pre></code></li>
            <li><strong>App.js </strong>App.js as usual imports the feature components to render them. To these components, App.js passes as props the slice of state for that components, and the dispatch method so that the components can dispatch actions to the store. Passing state through App to the components is called prop threading or drilling and isn't ideal, this is solved with react-redux library</li>
            <li><strong>feature components: </strong>These will use the slice of state passed in as props to render the component, import action creators from the associated Slice.js file, and run the passed in dispatch method with the action creators to run in response to user actions</li>
        </ul>
    </ul>

    <h2>React-Redux</h2>
    <ul>
        <li>The react-redux library optimizes using redux with react.  It must be installed in your project's root directory with <code>npm install react-redux</code>, which installs it as a production dependency.  It offers better ways of accomplishing several things when using redux with react</li>
        <li><strong>Provider Component: </strong>This is a component in the react-redux library which you will generally import into your index.js with <code>import { Provider } from 'react-redux';</code> You will then wrap your rendered App component inside the Provider Component and pass the store as a prop to your Provider component.  This will allow the App component and all children components access to the store without having to pass it as props. e.g. index.js will render:
        <code><pre>
            ReactDOM.render(
                &ltProvider store={store}>
                    &ltApp />
                &lt/Provider>,
                document.getElementById("root")
            );
        </pre></code></li>
        <li><strong>Selectors: </strong>Selectors are functions you write in each feature's featureNameSlice.js file, which contains the action creators, initial state, and reducer for one slice of state.  There is nothing to import from react-redux to implement these, they just use vanilla js. The selector functions take the full state as an argument (i.e. all slices of state) and return just one slice of state, or perhaps some sub part of that slice, or filter the slice first, etc.  They should deal with the slice in the slice.js file they are in.  They need to be pure functions that do not mutate the argument, and always provide the same output for same input with no randomness or side effects.  They should be named selectDescriptionOfDataReturned, e.g. selectAllRecipes or selectFilteredRecipes.  They should be exported so they are available for import where needed, in other slice files or UI components.  They can be as simple as returned a slice of state, e.g. <code>export const selectFilter = state => state.filter;</code> or more complicated like returning only the todo items in the state.todos array that are marked as complete or filtering state.AllRecipes array in the allRecipesSlice.js file based on state.searchTerm that is retrieved by importing selectSearchTerm from the searchTermSlice.js file:
        <code>
            <pre>
                export const selectIsCompleteIDs = state => state.todos.filter(
                    todo => todo.isComplete).map(todo => todo.id)
            </pre>
        </code>
        <code>
            <pre>
                export const selectFilteredAllRecipes = (state) => {
                    const allRecipes = selectAllRecipes(state);
                    const searchTerm = selectSearchTerm(state);

                    return allRecipes.filter(recipe => recipe.name.toLowerCase().includes(searchTerm.toLowerCase()));
                }
            </pre>
        </code>
    </li>
    <li><strong>useSelector: </strong>This method is provided by react-redux for use in React components and must be imported in the component with <code>import { useSelector } from 'react-redux';</code> You'll also need to import selector functions from one or more slice.js files to use the selectors.  You use useSelector in a component definition (inside the component class definition or function definition of function components), providing it an argument of a selector.  useSelector must be used within a child component under the top level Provider component.  It will feed the selector the current state of the store, and return whatever the selector returns.  However, it will also subscribe rendering of the component to the store, but only for changes to the slices involved in the selector function.  So, components will re-render only when slices update that effect them.  You don't have to use a separately defined selector function with useSelector, and can instead define the selector in line with useSelector, e.g. <code>const todos = useSelector(state => state.todos);</code> or could use props passed to the component in the selector e.g. <code>const todo = useSelector(state => state.todos[props.id])</code></li>
    <li><strong>useDispatch: </strong>This method is provided by react-redux for use in React components and must be imported in the component with (also importing useSelector in this example) <code>import { useSelector, useDispatch } from 'react-redux';</code>.  This method simply returns the store's dispatch method, so that you can use dispatch in your component without having to pass it down through props (from index.js to App.js to the component).  In your component definition (inside your component class body or function body for function components), you would include <code>const dispatch = useDispatch()</code>.  Then you can use dispatch like normal, e.g. in response to a button click you might use <code>dispatch(removeTodo(todo))</code>, where removeTodo is an action creator that you imported at the beginning of the component file from the appropriate slice file, and this action creator happens to take an argument that it uses as payload to determine which todo should be removed.</li>
    </ul>

    <h2>Redux Toolkit</h2>
    <ul>
        <li>The redux toolkit (RTK) is a library that helps reduce some of the code you have to write to use redux.  It needs to be installed in the root of a project with <code>npm install @reduxjs/toolkit</code></li>
        <li><strong>createSlice() </strong>This is a method available in the redux toolkit and needs to be imported to the file using it with <code>import { createSlice } from '@reduxjs/toolkit';</code> It provides a way of more easily defining a slice reducer and associated action creators.</li>
        <ul>
            <li>createSlice accepts an object argument with three properties: name, initialState, and reducers.  This object may be defined first as a const called 'options' and provided to the createSlice() method.  The name property should be a string that is the name of the slice and the prefix used in the action types for the slice (e.g. todos is the prefix in todos/addTodo).  The initialState property is the initial state value for that slice.  The reducers property is an object with keys equal to the last half of each action type (e.g. addTodo). Each key is set to a function called case reducers that accept state and action arguments and returns the new state for that action. It is not necessary to define a default action.</li>
            <li>createSlice returns an object with three properties: name, reducer, and actions, and which you normally would save to a const named nameSlice (e.g. todoSlice).  The name is the name you provide in the options object. The reducer is an automatically generated slice reducer function that essentially creates a traditional switch statement with the code you provided for each possible action in the options object, along with a default case that returns the state unchanged.  Finally, the actions property is an object whose keys are the names of the actions you provided in the options object (e.g. addTodo), and each key is set to an action creator function that accepts a payload argument and returns an action object of type name/action (e.g. todos/addTodo) and the payload provided.  You will want to export the action creators so they can be used elsewhere.  This is most commonly done with e.g. <code>export const { addTodo, toggleTodo } = todosSlice.actions;</code> where todosSlice is the name of the const you save the return value of createSlice.  You'll also want to export the reducer function so that it can be imported into the store to create the combined reducer, this is typically made to be the default export, e.g <code>export default todosSlice.reducer;</code></li>
            <li>createSlice also has the benefit that it uses the Immer library to allow you to write mutative code without actually mutating the provided arguments, so you don't have to worry about writing an immutable function, and can mutate the passed in state argument for easier code, and you don't have to return the new state, you can just mutate the current state (e.g. you can push to a state that is an array, instead of creating a copy of the array, mutating it and returning it).</li>
            <li>Example createSlice:
                <code><pre>
                    const todosSlice = createSlice({
                        name: 'todos',
                        initialState: [],
                        reducers: {
                            addTodo(state, action) {
                                const { id, text } = action.payload
                                state.push({ id, text, completed: false })
                            },
                            toggleTodo(state, action) {
                                const todo = state.find(todo => todo.id === action.payload)
                                if (todo) {
                                    todo.completed = !todo.completed
                                }
                            }
                        }
                    })
                        
                    /* Object returned by todosSlice */
                    {
                        name: 'todos',
                        reducer: (state, action) => newState,
                        actions: {
                            addTodo: (payload) => ({type: 'todos/addTodo', payload}),
                            toggleTodo: (payload) => ({type: 'todos/toggleTodo', payload})
                        },
                        // case reducers field omitted
                    }
                </pre></code>
            </li>
        </ul>
        <li><strong>configureStore() </strong>This is a method provided by redux toolkit that you would import into your store.js file with <code>import { configureStore } from '@reduxjs/toolkit';</code>.  It is passed a configuration object and it returns a store object that you would save to your const store, in place of create store.  The config object can have multiple properties but the most basic usage is a single property called reducer.  reducer is set equal to an object that has keys equal to the name of each slice of state, and values of the associated slice Reducer, which would be imported as usual in to the store.js file.  This reducer object is the same thing you would pass to combineReducers to create a root reducer.  Passing this config object to configureStore() will create a root reducer and create a store based on that root reducer, thus making the process a little simpler than combineReducers and createStore (which you don't have to import if you're using configureStore instead).  However, configureStore will also add middleware and set up Redux DevTools extension, thus saving you even more code. Example usage in a store.js file:
        <code><pre>
            import { configureStore } from '@reduxjs/toolkit'
 
            import todosReducer from './features/todos/todosSlice'
            import filtersReducer from './features/filters/filtersSlice'
            
            const store = configureStore({
                reducer: {
                    // Define a top-level state field named `todos`, handled by `todosReducer`
                    todos: todosReducer,
                    filters: filtersReducer
                }
            });
            
            export default store
        </pre></code></li>
    </ul>

    <h2>Redux Middleware and Thunks</h2>
    <ul>
        <li><strong>Middleware</strong> refers to the code in a system that runs between receiving a request and producing a response. In redux, middleware runs between the moment an action is dispatched, and the moment the reducer is called with that action. Common middleware tasks include logging actions, caching, adding auth tokens to request headers, crash reporting, routing, and making asynchronous requests for data. There are many libraries you can use with redux to help accomplish these things, or you can write your own middleware.</li>
        <li><strong>applyMiddleware </strong>To write your own middleware, first import the applyMiddleware method from the redux library to your store.js file with (also importing createStore in this example) <code>import { createStore, applyMiddleware } from 'redux';</code>.  createStore() offers two additional arguments after the reducer argument.  The first is the initialState, and the second is for middleware.  To use middleware you call the applyMiddleware method in the middleware argument of createStore.  applyMiddleware takes one or more arguments, which are the middleware functions you want to run in order from first to last.  Dispatches to the store will actually call the first middleware function, then all preceding ones, and then finally call the store's reducer. e.g. 
        <code><pre>
            const store = createStore(
                exampleReducer, 
                initialState, 
                applyMiddleware(
                    middleware1, 
                    middleware2, 
                    middleware3
                )
            );
        </pre></code></li>
        <li><strong>Custom Middleware functions: </strong>Middleware functions (middlewares) included in the applyMiddleware() function must conform to a specific pattern, shown below.  This pattern gives each middleware access to the store's methods (dispatch, getState) through the storeAPI, the next middleware, and the action. For the last middleware in the pipeline, next will be calling store.dispatch(action) to finally run the reducer.  The pattern is you do stuff for that middleware, then you return a call to the next middleware with that action.
        <code>
            const exampleMiddleware = storeAPI => next => action => {
                // do stuff here
                return next(action);  // pass the action on to the next middleware in the pipeline
            }
        </code>
        Example of one logging middleware:
        <code><pre>
            import { createStore, applyMiddleware } from 'redux';

            const messageReducer = (state = '', action) => {
                if (action.type === 'NEW_MESSAGE') {
                    return action.payload;
                } else {
                    return state;
                }
            }

            const logger = storeAPI => next => action => {
                console.log(storeAPI.getState());
                
                const nextState = next(action);
                console.log(nextState);

                return nextState;
            };

            const store = createStore(messageReducer, '', applyMiddleware(logger));

        </pre></code></li>
        <li><strong>Asynchronous Actions in Redux: </strong>Barriers to asynchronous actions in redux include, async actions return promises, but dispatch expects a plain object and runs the reducer with it immediately (e.g. the payload can't be a promise that returns a value later, the reducer will have run by then). Additionally, reducers are supposed to have no side effects or indeterminate logic, so async logic in the reducer itself is a no-go.  Redux recommends async operation should happen as part of the action creation process.</li>
        <li><strong>Thunk</strong> A thunk is a function that is set up and returned by another function, so that it can be called later when needed. e.g. <code>const add = (x, y) => { return () => { return x+y }}</code> creates a function called add that takes two number to add, but instead of returning the result, it returns a thunk function that will return the result if called later.</li>
        <li><strong>redux-thunk </strong>This is a library that is automatically included with RTK and applied to a store automatically if you use configureStore().  You can use it standalone without RTK as well but need to install and import it.  It allows you to write action creators that return asynchronous functions (thunks) instead of action objects.  You can also continue to write action creators that return plain action objects.  When you call <code>dispatch(actionCreator())</code> somewhere in your codebase, the dispatch call will first go to thunks middleware instead of straight to the reducer.  If the action creator returns a plain action object, then thunks will pass it along to the reducer.  If the action creator returns a function, then thunks will run the function, providing it three arguments: dispatch, getState, and extraArugment.  Not sure what extraArgument is for, but dispatch and getState will be those methods from your store so the can be used in your function definition.  getState and extraArgument are optional arguments.  These types of action creators are helpful if you need to dispatch an action that has an async operation a part of it.  The action creator itself can accept any arguments you need or none at all, e.g. you might want to give the action creator an id, so this id is in the returned thunk and is used to make an api call.  The thunk can have up to three parameters as discussed above, the dispatch, getState, and extraArgument parameters.  You will call dispatch at the end of your thunk with a plain action object (perhaps with a payload recieved from an api call).  When this plain object is dispatched it will go through thunks again but this time be passed straight away to the reducer.
        <code><pre>
            import { fetchUser } from './api'
            const getUser = (id) => {
                return async (dispatch, getState) => {
                    const payload = await fetchUser(id);
                    dispatch({type: 'users/addUser', payload: payload});
                }
            }
        </pre></code></li>
        <li><strong>Promise lifecycle: </strong>When fetching from an API and creating a promise, for better UX it is good for your app to respond to different parts of the promise lifecycle, i.e. when it is pending, when it fulfills, and if it is rejected.  A manual way of doing this is to have separate actions for each phase that you dispatch at the right time to update your state and thus UI.  E.g. for fetch user example above, you could write: 
        <code><pre>
            const fetchUserById = (id) => {
                return async (dispatch, getState) => {
                    dispatch({type: 'users/requestPending'})
                    try {
                        const payload = await fetchUser(id)
                        dispatch({type: 'users/addUser', payload: payload})
                    } catch(err) {
                        dispatch({type: 'users/error', payload: err})
                    }
                }
            }
        </pre>
        </code></li>
        <li><strong>createAsyncThunk(): </strong>This is a method available in the RTK, it needs to be imported with <code>import { createAsyncThunk } from '@reduxjs/toolkit';</code> It takes two arguments, an action type, and a payload creator, and it returns a function meant to be used as an action creator that returns a thunk. So, you would set your action creator equal to a call to createAsyncThunk().  The first argument the action type, is the action type that will be used for the eventual action object to dispatch.  The second argument is an async function that takes two arguments, 'arg', and 'thunkAPI', and returns the payload you want to use in your eventual action object to dispatch.  When you call the action creator you can provide it a single argument that will be passed own to 'arg' in the async function.  It will be undefined if nothing is passed down.  If you only need to pass one value, you should name the parameter semantically, if multiple values are needed, you should call it 'arg' and pass it an object with the multiple values.  The 'thunkAPI' parameter gives you access to store.dispatch, store.getState, and other things.  createAsyncThunk() will dispatch all three actions of the promise lifecycle, based on the name you provide in the first argument, appended with '/pending', /'fulfilled', or '/rejected'.  (e.g. if you provide 'users/fetchUserById', it will dispatch the actions 'users/fetchUserById/pending', 'users/fetchUserById/fulfilled', or 'users/fetchUserById/rejected').  You can then respond to these actions in your reducer.  On the fulfilled action, it will include as payload whatever you return from the async function in the second argument.  Additionally, it will return action creators with these three actions separately if you want to force a dispatch of the particular action.  These can be called with the name you give the action creator const variable, e.g. fetchUserById.pending(), fetchUserById.fulfilled(), and fetchUserById.rejected().
        <code>
            <pre>
                import { createAsyncThunk } from '@reduxjs/toolkit'
                import { fetchUser } from './api'
                const fetchUserById = createAsyncThunk(
                    'users/fetchUserById', // action type
                    async (userId, thunkAPI) => { // payload creator
                        const response = await fetchUser(userId);
                        const json = await response.json();
                        return json;
                    }
                )

                //call on user id 17
                dispatch(fetchUserById(17));
            </pre>
        </code>
        Multiple args:
        <code>
            <pre>
                const searchUsers = createAsyncThunk(
                    'users/searchUsers',
                    async ({ firstName, lastName}, thunkAPI) => {
                        // perform the asynchronous search request here    
                    }
                )
            </pre>
        </code>
        </li>
        <li><strong>Extra Reducers: </strong>If using createAsyncThunk, and using createSlice to make your reducer and actions for the slice, you will have an issue because createAsyncThunk will create three action types that are not included in your reducers property in the options object given to createSlice().  createSlice allows a fourth options object property called 'extraReducers'.  The value of it is an object where you will want to add a property for each of the three action types, and give it a case reducer function.  Often you'll see state values for isLoading and isError, that are booleans used to respond to the promise lifecycle actions.  e.g. your usersSlice would be set to a call to createSlice, and it takes an options object, and you would include the extraReducers property:
        <code>
            <pre>
                extraReducers: {
                    [fetchUserById.pending]: (state, action) => ({
                        state.isLoading = true;
                        state.hasError = false;
                    }),
                    [fetchUserById.fulfilled]: (state, action) => ({
                        state.users.push(action.payload);
                        state.isLoading = false;
                        state.hasError = false;
                    }),
                    [fetchUserById.rejected]: (state, action) => ({
                        state.isLoading = false;
                        state.hasError = true;
                    })
                }
            </pre>
        </code></li>

    </ul>

    <h2>Redux DevTools</h2>
    <ul>
        <li>This is a chrome extension to help you inspect redux apps.  You must configure your store to work with DevTools.  However, if you use the configureStore method of RTK, then this configuration will happen automatically and no further configuration is required. The redux extension can be found in the inspect window.</li>
        <li><strong>State: </strong> The state tab allows you to inspect the store's state.  There are three views that all have the same info.  The tree view shows the current value of the state object as a expanding/collapsing menu.  The chart view shows you the state as a tree structure, so that the state is the root, with each slice of state as children, and then the children of those slices if they are objects.  Finally the raw view shows you the state in javascript object syntax.</li>
        <li><strong>Actions: </strong>The action tab shows you the action object that was most recently dispatched (you'll notice an @@INIT action when the app first loads that set the state to its initial value).  Again there are the same three views like with state, they all contain the same information.</li>
        <li><strong>Diff: </strong>This shows you a depiction of the previous state and the new state after the last action, so you can see what slices of state changed, and there previous value and new value.</li>
        <li><strong>Trace: </strong>This will show you where an action was dispatched in your code, showing you the call stack. </li>
        <li><strong>Test: </strong>This will provide template code that you can copy and paste into a test file, in jest, mocha, and other frameworks.  It writes the test based on the previous state, the action just taken, and the new state afterwards.</li>
        <li><strong>Dispatch: </strong>The keyboard button (Dispatcher) in the middle of the row of buttons at the bottom of the screen allows you to type an action object (i.e. of a given type and with some payload), and dispatch it, it will update the state just like a regular action dispatched in your app.</li>
        <li><strong>Inspector: </strong>The inspector pane shows you the history of actions on the page.  You can jump to any of the actions to go back to the state after that action.  You can use the play/pause buttons at the bottom of the screen to move forward in the actions. You can select to skip an action so that it doesn't dispatch when you replay the actions.  You can also filter actions by type to just see those associated with a give feature for example.  Action history is erased when you refresh the page (state is reinitialized)</li>
        <li><strong>Persist: </strong>The thumbtack button at the bottom (Persist) will keep your action history even if you refresh the page. Helpful to get back to a certain state. </li>
    </ul>
</body>
</html>