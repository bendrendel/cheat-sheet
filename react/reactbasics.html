<!DOCTYPE html>
<html>
    <head>
        <title>JSX</title>
    </head>
    <body>
        <a href="./index.html">Home</a>
        <h1>React</h1>
        <p><strong>React: </strong>React is a very popular user interface framework? developed at Facebook, comprised of two libraries, makes for faster apps, more modular and maintainable JS code, more scalable to large apps, more flexible to use beyond web apps</p>
        
        <h2>React Library</h2>
        <p><code>React library: </code>Javascript library containing methods for pure React purposes, mainly allowing you to write JSX with the React.createElement() method, and allowing you to make components with React.Component class</p>
        
        <h3>JSX</h3>
        <p><strong>JSX: </strong>JSX is a syntax extension for Javascript designed for use with the react library, that represents HTML elements in javascript code that can be rendered in the browser. Browsers cannot read this syntax, so any js file using it must be translated to regular Javascript using a JSX Compiler before being sent to a browser.  JSX creates a react element, as does the equivalent React.createElement() method</p>
        <p><strong>JSX Expression: </strong>JSX is treated as an expression by Javascript and can go anywhere a normal expression could go (saved to variable, passed to function, etc.) Composed of a single JSX element that may contain nested JSX elements, but there is only one root element. must enclose in parentheses if more than one line.</p>
        <ul>
            <li>
                <p><strong>Javascript injection: </strong>You can inject a regular javascript expression inside a JSX expression using curly braces {}, if the expression evaluates to an array of JSX elements, then the JSX elements will be rendered one after the other</p>
                <ul>
                    <li><p><strong>Conditional statements: </strong>if statements cannot be injected into a JSX expression due to compilation details.  Ternary operator does work inside jsx expression, as does utilizing short-circuit evaluation of && operator (if first expression is falsy then falsy is returned by the injection and ignored in the jsx element, but if truthy then the second expression is returned), or can use if statement outside of JSX expression</p></li>
                </ul>                
            </li>
        </ul>
        <p><strong>JSX Element: </strong>The building block of JSX syntax, is either HTML-like (if tag name isn't capitalized) or a Component Instance (if tag name is capitalized) HTML-like looks just like an html element with an opening/closing tag (or self-closing tag) and inner HTML content.  Component instances can use opening/closing tags or a self closing tag that is the name of the Component Class to make an instance of.  Self-closing tags must contain a closing forward-slash (unlike in normal HTML where they're optional).  </p>
        <ul>
            <li>Component Instances</li>
            <ul>
                <li><p><strong>Component Instances: </strong>Component instances will create an instance of the component and then run the render method (which often returns HTML-like JSX).  e.g. a component instance in the ReactDOM.render() method will run it's render method</p></li>    
                <li><p><strong>Attributes: </strong>Attributes in a component instance effectively create an object of key-value pairs from the attribute-value pairs which is passed in as the props object, the value can be a string (like HTML-like JSX would have), or you can pass a non-string data type by using an injected javascript expression</p></li>
            </ul>
            <li>HTML-like</li>
            <ul>
                <li><p><strong>Attributes: </strong>JSX Elements can have attributes just like HTML elements, the values of which can be enclosed in single or double quotes depending on style preference, or the value can be injected js. Some attribute names and/or values are a little different in JSX, particularly class in HTML is className in jsx due to class being a reserved word, className in JSX gets rendered as class. also event listener attributes are written in camelCase in JSX instead of all lowercase as in html (e.g. onMouseOver vs onmouseover) and their value should be a function (not an invoked function as in html). commonly, the event listener functions are written as arrow functions, so that this binds to the component object instead of the event target.  It's also common for the event listener function to be defined as a method of the component class outside the render method.  It's also common for a non-invoked function to be passed in as a prop to a component and then injected into the jsx as the event handler.  also the style attribute can be set equal to an injected object whose properties are css properties (some name differences in JSX) with whatever value you want to give them</p></li>
                <li><p><strong>'key' attribute for list elements: </strong>list elements sometimes need the key attribute included for list items, each list item given a unique key value, never hurts to use them if unsure, but they are needed if the list-items order might be shuffled between renders (e.g search results) or if the list items have memory between renders, e.g. it must be remembered if an item is checked off or not on a to do list.  This applies not only to list item elements, but any repeated element used to make a list, could be paragraphs, table rows, divs, etc.  For any dynamic list where elements may be added, removed,
                reordered, you should use a key.  The key needs to be unique in the list, for example could
                just equal the value of the list item, or maybe an id if the list items come from a database.
                by default if not assigned, a key will equal the index number of the list item, which can
                cause problem like when things are reorder, react can't follow the items around correctly</p></li>
                <li><strong>Styles: </strong>Components can have a separate css file that you import at the top of the file, this css file will apply styles to the rendered output of the component like normal (use classes, element selectors, etc). HTML-like jsx can have a <code>style</code> attribute to apply css styles, but it works a little differently than normal HTML.  The style attribute's value should be a javascript object.  The object contains key value pairs where the key is the name of the css style property, but is in camelCase instead of hyphenated lowercase like in css (e.g. backgroundColor instead of background-color).  This is the same as when you use the style property in regular JS on a DOM element, e.g. myElem.style.backgroundColor. The value should almost always be a string wrapped in single quotes, again like regular JS (e.g. myElem.style.backgroundColor = 'red'), and unlike in CSS where quotes generally aren't used.  The exception to this is for most styles, if you give them a numerical value, React will assume the unit is pixels, so <code>fontSize: 30</code> is interpreted as <code>fontSize: '30px'</code>.  
                <ul>
                    <li>
                    Often, inline styles in React are used by defining a <code>styles</code> const variable equal to a style object at the top level in a component's module above the exported component, then injected in the jsx of the component. The style variable might be named 'divStyle' or 'h1Style' and you may have several of them for the different jsx elements in the component.  Additionally, you might have a styles.js file in your project, that exports a 'styles' object which is then imported in multiple components and used in the style variables of each component.  e.g. your styles.js file might look like:
                    <code>
                        <pre>
                            const fontFamily = 'Comic Sans MS, Lucida Handwriting, cursive';
                            const fontSize = '4em';
                            const padding = '45px 0';
                            const color = 'green';

                            export const styles = {
                                fontFamily: fontFamily,
                                fontSize: fontSize,
                                padding: padding,
                                color: color
                            };
                        </pre>
                    </code>
                    then you would include an <code>import {styles} from './styles.js'</code> in each component, and in their 'divStyle' or 'h1Style', or other other style variables, if you need to define fontFamily for the element, you can set it equal to the imported fontFamily from the styles object.  additionally, instead of a single color property in styles.js, you might have multiple colors, like darkBlue, lightBlue, white, or mainColor, secondaryColor, etc.  and then you can use these imported colors as needed.  Same idea goes for any other property.  Or you might have one object of divStyles and another object of imgStyles, and export them both, or export them combined as object-valued properties of a single styles object.  Basically multiple ways to organize this.
                    </li>
                    <li><strong>Styled Components</strong> This is a styling library for react, install it in the root of your project with <code>npm install styled-components</code>. Then in any component you want to use it in, include <code>import styled from 'styled-components';</code> The basic usage is at the top of your Component file outside the component definition, you define variables for all of the regular html components you want to render in the component.  The variables are set equal to <code>styled.tagname``</code> to define the html tagname and styles in between the backticks (which can also be left empty if no styles are needed).  Then in your jsx, instead of regular html tags, you use the names of the variables to render a pre-styled version of the tag.  The variables should be named like react components in UpperCamelCase. The styling is just like css, and can also use the & selector to reference the component for use in psuedo selectors, and can use nested styles for styling psuedo selectors. You can also reference a styled element variable that was defined previously in the code with injection, use a psuedo selector with it, and then define styles for the current element with &.  E.g when you hover over a previously defined MyButton element, maybe you want the input to change color.  This would look like <code>${MyButton}:hover & {background-color: red;}</code>.  Also, you can extend the styles of a previously defined styled component, e.g. say you defined <code>const Button = style.button`...`;</code>, well you can create <code>const GreenButton = styled(Button)`...`;</code> to use the Button styles and add any additional styles on top of that.  Also, you can reference props passed to the component in the style definition, e.g <code>color: ${props => (props.primary ? 'violet' : 'palevioletred')};</code>
                    <code><pre>
                        const Input = styled.input`
                            font-size: 16px;
                            border: solid 1px #dbdbdb;
                            border-radius: 3px;
                            color: #262626;
                            
                            padding: 7px 33px;
                            border-radius: 3px;
                            color: #999;
                            cursor: text;
                            font-size: 14px;
                            font-weight: 300;
                            text-align: center;
                            background: #fafafa;
                            
                            &:active,
                            &:focus {
                                text-align: left;
                            }
                        `
                    </pre></code>
                    Then in your jsx to be rendered, you would include
                    <code>&ltInput type="text" placeholder="Search" /></code> to create an html-like input element, but prestyled per above styling.</li>
                    <li><strong>Global styles with styled components: </strong>You can create a global style with styled components by creating a globalStyle.js file under src/theme/globalStyle.js.  This file has <code>import { createGlobalStyle } from 'styled-components';</code> and then defines and exports a const variable like <code>const GlobalStyle = createGlobalStyle``;</code> where inside the backticks you define your css that should apply globally, e.g. styling to the body element, to all code elements, etc.  Now you import and include that GlobalStyle component at the top of the React tree to apply it, for some reason using the fragment component. Like so:
                    <code><pre>
                        import React, { Fragment } from 'react';
                        import styled from 'styled-components';
                        import Header from './components/Header.js';
                        import Profile from './components/Profile.js';
                        import GlobalStyle from './theme/globalStyle';
                        
                        const AppWrapper = styled.div`
                            background-color: #fafafa;
                        `;
                        
                        function App() {
                        return (
                            &ltFragment>
                            &ltGlobalStyle />
                            &ltAppWrapper>
                                &ltHeader />
                        
                                &ltProfile />
                            &lt/AppWrapper>
                            &lt/Fragment>
                        );
                        }
                        
                        export default App;
                    </pre></code></li>

                </ul>
                </li>
            </ul>
            <li><code>React.createElement()</code> JSX elements are compiled by babel to an invocation of the createElement() method of the React library, and you can use this method yourself to create elements.</li>
                <ul>
                    <li>The function takes a first argument of the type of element, a second element with an
                        object containing the element's attributes (null if none), and any number of additional
                        arguments that are appended together one after the other as the inner HTML of the element
                    </li>
                    <li>For instance the two snippets below are equivalent
                        <code><pre>
                        return (
                            &ltdiv className="shopping-list">
                                &lth1>Shopping List for {this.props.name}%lt/h1>
                                &ltul>
                                    &ltli>Instagram&lt/li>
                                    &ltli>WhatsApp&lt/li>
                                    &ltli>Oculus&lt/li>
                                &lt/ul>
                            &lt/div>
                        );
                        </pre></code>
                        <code><pre>
                        return React.createElement('div', {className: 'shopping-list'}, 
                            React.createElement('h1', null, 'Shopping List for', this.props.name),
                            React.createElement('ul', null, 
                                React.createElement('li', null, 'Instagram'),
                                React.createElement('li', null, 'WhatsApp'),
                                React.createElement('li', null, 'Oculus')
                            )
                        );
                        </pre></code>
                    </li>
                </ul>
        </ul>

        <h3>Components</h3>
        <p><strong>Component: </strong>React applications are made out of objects called components, which are small reusable chunks of code responsible for one job, often to render HTML, all are instances of a component class, React applications can contain dozens or even hundreds of components</p>
            <ul>
                <li>Components should each ideally do one thing, and are generally nested with subcomponents.
                    The breakout of components oftens mirrors the data model of what you're representing.
                </li>
            </ul>
        <p><strong>Component Class: </strong>made by subclassing the React.Component class,  component class names must be capitalized for use in JSX (should be anyway like any class)</p>
        <ul>
            <li><strong>render method: </strong>for every component class, you must define a render() method that can contains logic, can access other methods and properties of the component class such as the props property using this.props.propertyname, can access variables outside the component class</li>
            <ul>
                <li><p>Render method must include a return statement that returns a react element, typically in the 
                form of a jsx expression which can include component instances and/or HTML-like JSX.  As in the ReactDOM.render method, component instances run their render method, and can have attributes to set props</p></li>
            </ul>
            <li><p><strong>props property: </strong> this is a property of the React.Component class whose constructor takes a single argument (an object) that props gets set equal to.  The prop object's properties can then be accessed in the body of a Component Class (e.g. this.props.myProp), but a component should never change the value of its props, it should be given those values upon instantiation.  It's value is typically set using attributes in a Component Instance, used to pass information to component, values can be any data type including functions like event handlers, which should be named the same as the event listener attribute like onClick or onKeyPress. </p></li>
            <ul>
                <li><p><code>props.children </code> props always has a property called children which returns the innerHTML of the component instance.  If the component instance is self-closing, then it will be undefined.  If the innerHTML contains multiple child elements then they will be placed in an array in props.children, if only one or no children then just the single child or value is returned and not placed in an array.  This could be handy if e.g. you have a component that displays a passed in list,
                well instead of passing it in as a prop, you could render the component as having an opening
                and closing tag instead of self-closing, and put the li elements inside there, just as you would 
                inside an unordered list element.  Then, in the definition of the component, you could have it 
                in the render method that it returns this.props.children to have it return all the li elements that 
                were inside it. </p></li>
                <li><strong>propTypes: </strong><code>propTypes</code> is a way to validate the data type of props being passed in to a component that is passed props, and a good way to document the expected props to be passed in to a component.  To use propTypes on a component, you first need to import the library using <code>import PropTypes from 'prop-types';</code>. Then after your class component declaration or function component declaration, outside the class or function body, you use <code>MyComponent.propTypes = {}</code> to add a static property to your class component or function component.  Inside the propTypes object you should have one property for each prop passed into your component, of the form <code>myFirstProp: PropTypes.string</code> where myFirstProp is the name of the prop, and PropTypes.string  gives the expected data type of the prop (error thrown if not matching).  The data type can be .string, .object, .bool, .number, .func, or .array.  Additionally you can add .isRequired to throw an error if the prop is not provided, e.g. myProp: PropTypes.number.isRequired</li>
            </ul>
            
            <li><p><strong>constructor method: </strong>you have to include a constructor method to add a property inside the component class body (by including this.propertyname = 'value' in the constructor, you can also add properties after the component class has been declared e.g. MyComponent.propName = 'value'), if you do have a constructor method, it must accept a props argument and call super(props) to ensure the constructor of the React.Component class is invoked with any provided props (this happens automatically via the default js constructor when a component class has no constructor) </p></li>
            <li><p><code>defaultprops</code> this is a property that can be defined for a component class that has an object value and the properties are the names of the component class's props and the values are default values to use if a Component Instance does not set the prop.  Possibly common to define this outside the class component, i.e. you define the class component named MyComponent, and then outside of that class definition, you define MyComponent.defaultprops = {myprop: 'default-value'}</p></li>
            <li><p><strong>state property: </strong> a property you can create, an object, usually created in the constructor of a component class and given an initial value, the state property can then be accessed in the body of the component class (e.g. inside body use this.state.someThing), and unlike with props, the state can be changed inside the component class body.  You generally should group state variables together in objects (i.e. this.state.myObj) only if they are related and update together. Otherwise, they shoul dbe in different properties of state (i.e. this.state.firstVar and this.stat.secondVar</p></li>
            <li><p><strong>setState method: </strong>this is a method in the React.Component class, it takes two arguments, the first an object to update the components state with, and secondly a callback that is almost never needed.  after updating the state, it also calls the component's render method, thus it causes immediate changes on screen and cannot be called inside the render method to avoid an infinite loop. The first argument updates the component's current state by updating any of the currents state's properties to the values in the provided object if has that state property.  the provided argument doesn't have to include all of the state's properties.  the most common use of setState is calling it inside a method (especially an event handler) of the component class. You can also use a function as the first argument that returns an object which will be used to set the state.  This function can have a parameter for the previous state, commonly called prevState which can be useful if needing info from the prev state.</p></li>
            <li><strong>Array state variable tricks: </strong> State variables that are arrays are often used to create a series of jsx elements.  This can be done by calling the .map method on the array in your rendered jsx.  You might be creating list items, buttons, or something else for each item in the array.  Generally you'll want to have a key attribute on the jsx elements you create, which is a unique value and might just be the value of the array element itself if those are all unique, or maybe you call map with the optional index argument and use that as the key.  Another good trick with arrays is the spread operator when updating the value of an array state variable.  Your previous value of the array might be prevState, and you have a new value newItem to add to the array.  This can be done with setState(prevState => ({myArrayStateVar: [...prevState.myArrayStateVar, newItem]}))</li>
            <li><strong>Object state vairiable tricks: </strong>Object state variables are often used to store form inputs, and if each input on the form has a name attribute and a value attribute, it can be useful to store them in an object state variable with each key as the name and their associted value. You'll often have an event handler that sets the state in response to changes on each input element.  They can all use the same event handler but use the target name and value properties to respond to each input element properly.  You can use the spread operator and keep in mind that later key/values in the object will overwrite earlier ones. So, your event handler would take in the event target as an argument and contain a call as follows: <code>setState(prevState => ({myObjectStateVar: {...prevState.myObjectStateVar, [name]: value}}))</code></li>
            <li><p><strong>event handler methods: </strong>commonly methods are used to define event handlers that are injected into the rendered html and by convention these should be named something like handleClick or handleKeyPress, depending on the name of the event they handle. If you use 'this' inside an event handler method, then you must include a constructor method in the component class that includes a line to bind the method to 'this'.  (e.g. this.myEventHandler = this.myEventHandler.bind(this)) this is because when the method is injected into jsx as an event handler, it will lose its this, so it needs to have the object name already in place of this</p></li>
            <li><strong>other methods: </strong>the component can also have other methods</li>
        </ul>        
        <p><strong>Modularity: </strong>Common to place each component in its own file, and then used ES6 named import/export or ES6 import/export default to import component modules into other component modules e.g. to render one component with another</p>
        <p><strong>Dynamic Information: </strong>information that can change, components get dynamic information through props (info from outside) and state (info decided by component itself), every other value used in a component should always stay exactly the same</p>
        <p><strong>Process of determining components/state/props: </strong>
            <ul>
                <li>Lay out your components according to your data model.</li>
                <li>Build a static version of the site first, building the component classes, and using props to pass data from parent to child components.  You won't use state at all in the static version because state is for interactivity, i.e. data that changes over time.  All your components will only have render methods and the top level component will be passed your data model as a prop (e.g. some JSON from an API).</li>
                <li>Now determine the minimum number of state variables needed.  Think of all the pieces of data on your site, e.g. an original list of products, a filtered list of products, text in a search field, a filtering checkbox.  If the data is passed in from a parent via props, never changes, or can be computed based on any other state or props, then it's probably not a state variable.  So, an original list of JSON products is passed in to the app via props and isn't state, and the filtered product list can be computed if you know the search field text and filtering checkbox value, and the search field and checkbox are the only two state variables.</li>
                <li>Now determine which component should house each state variable.  It should be housed in a component that is a common parent of all children using the state.  It will pass the state down
                to all of the children that need it as props.
                </li>
                <li>Now you can pass down functions to children as props that update the state of the parent.
                e.g. the value of a search bar component is a state variable in a parent component that is passed
                down as props to the search bar component.  The search bar is also passed a function from the parent
                component as props that will update the parent state variable whenever there is an on input event
                in the search bar.
                </li>
            </ul>    
        </p>
        <p><strong>Component lifecycle: </strong>Component instances go through potentially three stages: mounting, updating, and unmounting. Each stage has is own lifecycle methods. These are used for code that has side effects, such as fetching data from a backend, subscribing to a stream of data, managing timers and intervals, and reading from and making changes to the DOM.</p>
        <ul>
            <li>Mounting first calls the constructor(), then render(), then componentDidMount(). The constructor should only do things without side-effects, calling super(props), initializing
            the state, etc.  The render function makes it appear for the first time.  Then, the componentDidMount() method can be included in your component class definition to run code that does have side effects.  e.g. for a clock, the constructor sets the intial time as a state variable, then render renders it, then componentDidMount can start an interval that updates the state variable every second with the new time.  Another example, you may fetch data asynchronously from a server in componentDidMount(), and store that data in a state variable when it arrives, which is rendered in your JSX in some way.  Be careful here because your JSX will render before componentDidMount() runs, meaning the data will not have been fetched yet, so you need some conditional logic in your JSX to show a 'loading' message if the state variable is null.  Once the data is fetched and the state variable is updated, a rerender occurs and the state variable will have data in it thus fulfilling the condition that renders it in your JSX.  Side effects include asynchronous functions like setInterval or AJAX calls, manually tweaking the DOM, setting a global value and more.
            </li>
            <li>Updating occurs whenever setState() is called or when props are updated.  It will first run render() and the componentDidUpdate().  componentDidUpdate is a good place for code with side effects that should run with each update.  e.g. perhaps the clock is passed a prop that determines if it updates every second or ever millisecond, then you should deal with resetting the interval in the componentDidUpdate() method that checks the value of the prop and updates
            the interval if necessary every time an update occurs.  It's often useful to use the prevProps
            object to compare the current value of a prop to the previous value to determine if something needs to be done because the prop changed.  prevProps is passed in as an argument to componentDidUpdate.  e.g. componentDidUpdate(prevProps) {if (this.props.myProp !== prevProps.myProp) {go fetch new data or something}}.
            </li>
            <li>Unmounting calls the componentWillUnmount() method.  You should define this method in your component class definition to clean up any side effects in your componentDidMount method, e.g. you can use clearInterval() to stop the clock interval from continuing.  Side effects like this should always be cleaned up in your componentWillUnmount() method to avoid memory leaks.</li>
        </ul>

        <h3>Function Components</h3>
        <p>Components can also be created as functions instead of classes. Originally functions could only accept props and return some jsx, but hooks have expanded their ability.  In the latest versions of React, function components can do everything classes can do, and are preferred by some developers for their simplicity and straightforward features.  For function components you need to import the React library.  Every time a function component rerenders, the entire function is called from top to bottom.</p> 
        <p>Function components should return the jsx 
            normally found in the render method of a class component.  The function can have a parameter of props to access props in the function body, accessed like props.propName (note you don't have to precede it with 'this.' like you would in a class component).  Function component names should be capitalized. The following are equivalent:
        </p>
        <code><pre>
            export class MyComponentClass extends React.Component {
                render() {
                    return &ltdiv>Here is a prop: this.props.myProp&ltdiv>
                }
            }

            export const MyComponentFunction = (props) => {
                return &ltdiv>Here is a prop: props.myProp&ltdiv>
            }
            </pre>
        </code>
        <p>Hooks allow you to manage state and lifecycle methods with function components.  Hooks can only be used within React function components (not class components or other types of functions). (Hooks can actually also be used in Custom Hooks but not sure what that is).  Hooks should also always be defined at the top level within your function component, i.e. don't include them inside loops or conditional statements or inside function expressions in the function component. This is because react requires every hook to be called on every render, so they can't be buried in something conditional.</p>

        <h4>Hooks - Use State</h4>
        <ul>
            <li>useState is a function from the React library that allows for state management with function components</li>
            <li>You'll often see people use import default to import React along with a named import to specifically import certain React features like useState, e.g. <code>import React, { useState } from 'react';</code>, you don't have to do this you can just import the React library like normal, but it allows you to use useState in your code directly instead of React.useState</li>
            <li><code>useState(initVal)</code> is used to set up a single state variable with an optional initial value of initVal (if you don't include an initial value it will be initialized as undefined, but in this case usually people explicitly initialize it using null or an empty string as the initial value instead of leaving it undefined).  It returns an array of two elements: the first is the current value of the state variable and the second is a function that changes the value of the state variable.  Most commonly these are saved using destructured assignment like so: <code>const [myStateVar, setMyStateVar] = useState(myInitVal);</code></li>
            <li>Now, myStateVar can be used in the returned jsx of your function component to return the state variable value, and the setMyStateVar function can be invoked with a new value for the state as an argument to set the state and trigger a rerender of the component.  e.g. <code>
                <pre>
                    return (
                        &ltdiv>
                            &ltp>Toggle value: {myStateVar}&lt/p>
                            &ltbutton onClick={() => setMyStateVar('ON')}>ON&lt/button>
                            &ltbutton onClick={() => setMyStateVar('OFF')}>OFF&lt/button>
                        &lt/div>
                    )
                </pre>
            </code></li>
            <li>For more complicated event handlers and maybe all event handlers, you don't want to define the handler in-line as above.  You'll often see variables defined in function components that are event handlers, and are injected into the returned jsx. Destructured assignment can be used to grab the target from the event object e.g. <code>
                <pre>
                    function myComponent() {
                        const [input, setInput] = useState('');
                        const handleChange({target}) {
                            setInput(target.value);
                        }
                        return (
                            &ltinput value={input} onChange={handleChange}>
                        )
                    }
                </pre>
            </code></li>
            <li>The method returned by useState to change the state, can also be given a function argument instead of just the new value you want.  The function argument takes the previous state value as an argument and should return the new state value you want.  e.g. you might have <code>[counter, setCounter] = useState(0);</code> and you might use setCounter like so <code>setCounter(prevState => prevState + 1)</code> You might think of using <code>setCounter(counter+1)</code> and this may work a lot of the time, but it might not in more complex apps and using the previous state as shown first is recommended.</li>
        </ul>

        <h4>Hooks - Use Effect</h4>
        <ul>
            <li>useEffect is a function from the React library that allows us to create lifecycle methods for function components</li>
            <li>As with useState, you'll see people import default React plus the specific functions such as <code>import React, { useState, useEffect } from 'react';</code></li>
            <li>The first argument for useEffect is a callback function to run after every render, equivalent to using the same code in both componentDidMount and componentDidUpdate in a class component.  e.g. <code>useEffect(()=>{document.title = myVar;})</code></li>
            <li>The callback function can also return a function which will run right before every re-render and right before the component unmounts.  This is the place to clean up memory leaks, like stopping a timer, removing event listeners, etc.  e.g. <code>useEffect(()=>{document.addEventListener('keydown', handleKeyDown); return ()=>{document.removeEventListener('keydown', handleKeyDown);};})</code></li>
            <li>The second argument for useEffect is the dependency array, which contains an array of values where if one of them changes, useEffect's callback will run on the next re-render and the returned cleanup function will run right before the next re-render.  If the dependency array is left out, the the callback runs on mounting and every re-render, and the returned cleanup function runs before every re-render and before unmounting.  If the dependency array is an empty array, then the callback will only run on mounting, and the returned cleanup function will run only before unmounting.  </li>
        </ul>

        <br> 
    
        <h2>ReactDOM Library</h2>
        <p><code>ReactDOM library: </code>JavaScript library containing several React-specific methods for interacting with and rendering to the DOM such as ReactDOM.render().  You don't need to include this in component modules
        that don't render anything, and are just imported into other modules that do the actual rendering with
        ReactDom.</p>

        <h3>Rendering</h3>
        <p><strong>Virtual DOM: </strong>In React, every DOM object gets a corresponding virtual DOM object.  When a JSX element is rendered, all virtual DOM objects are updated, then compared to a snapshot before updating (diffing), then only changed objects get updated in the real DOM. this is much faster than many frameworks that update the DOM inefficiently by updating more object than needed (e.g. updating a whole list instead of just the item that changed)</p>
        <p><code>ReactDOM.render(jsx, appendtoelement)</code> this is a method of the ReactDOM library that will append the first argument jsx expression to the second argument expression that returns a DOM element, thus rendering the JSX in the browser, if the jsx expression is a Component Instance then its .render() method is automatically invoked which typically returns html-like jsx that will then be rendered</p>
    </ul>  
    </body>
</html>