<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Router</title>
</head>
<body>
    <a href="../index.html">Home</a>
    <h1>React Router</h1>
    <ul>
        <li>React Router is a popular library to use with react to create "multi-page" react apps or client-side routing. For web development it should be installed in the root folder of your app using <code>npm install --save react-router-dom@5.2.0</code> to save it to production dependencies (default when no flag used with npm install). Note in 2022 react router v6 was introduced with breaking changes, below is about v5.</li>
        <li><strong>Router: </strong>Typically you will create a router component at the top level of your app and render your entire app as a child of the router component (the router child must have only one top-level jsx element).  All other components of this library must be decendents of the router component to work.  The router component creates a history object that keeps track of the URL and re-renders whenever the URL changes. To use the Router you must include <code>import { BrowserRouter as Router } from 'react-router-dom';</code> at the top of the file (the alias Router is optional but very commonly added).  You can alternatively import and use <code>HashRouter</code> if the server you are using can only render static pages (BrowserRouter is for servers that can handle dynamic requests).  A typical setup would be to import Browser Router in your index.js file, and render your App.js component as a child of it like below (of course also importing React, ReactDOM and the App component, along with any other imports).  (If using React.StrictMode and/or redux, then the React.StrictMode component should be the top component, then the Provider component, then the Router component, and finally the App component)  Alternatively, you could import the Router component into your App component, and wrap the JSX returned by your App component in a top-level instance of a Router component.  You'll leave index.js alone so it will still simply render your App component, which achieves the same exact nesting as the first way of doing it, since the Router will be the first thing returned by the app component with the original app contents inside it.  In this case, the Router component in your App component could have multiple children, or perhaps just one top level div that itself may have multiple children with everything your App needs to render.
        <code><pre>
            ReactDOM.render(
                &ltRouter>
                    &ltApp />
                &lt/Router>,
                document.getElementById('root');
            )
        </pre></code></li>
        <li><strong>Route: </strong> When you want to render a component conditionally on the URL, you use the Route component.  It must be imported with <code>import { Route } from 'react-router-dom';</code> The route component takes a path prop set to a string value of the pathname to match, note it matches everything after the top level domain (e.g. everything after .com) but everything before any query parameters or fragment identifiers (i.e. everything before ? or #).  It also takes a 'component' prop set to the injected component name (the component must be imported into the file). When rendered this component will automatically be passed a 'location' prop, the 'history' prop, and a 'match' prop.  The match prop is an object with a 'url', 'path', 'isExact', and 'params' property.  Instead of a component prop, the Route component can use the 'render' prop which takes an injected function that has a props argument for the automatically passed props, and is useful if additional props are needed.  e.g. <code>&ltRoute path='/page' render={(props) => (&ltPage {...props} data={{extraProp: 'propValue'}}/>)} /></code> or instead of rendering a component it can render some html-like jsx directly if a full component isn't needed, e.g. <code>render={()=>(&lth1>Welcome&lth1>)}</code>.  Finally, you can also include the component to render as a child of Route, and make the Route component not self-closing.  When the component is a child you can include prop attributes like normal. So, for example you could include <code>import { BrowserRouter as Router, Route } from 'react-router-dom'</code> in your App.js file, and App.js could return the code below, which would render the About component when the url is www.example.com/about, and similarly for signup and articles.  It will always render the Header and Footer compnents, which optionally could have been written as children of Route compnents themselves, except the Route components are given no path prop, which will mean those Routes will match all urls and therefore always render.
        <code><pre>
                &ltRouter>
                    &ltHeader />
                    &ltmain>
                        &ltRoute path='/about'>
                            &ltAbout />
                        &lt/Route>
                        &ltRoute path='/signup'>
                            &ltSignUp />
                        &lt/Route>
                        &ltRoute path='/articles'>
                            &ltArticles />
                        &lt/Route>
                    &lt/main>
                    &ltFooter />
                &lt/Router>
        </pre></code>
        </li>
        <li><strong>Link/NavLink: </strong>The link component can be imported with <code>import { Link } from 'react-router-dom';</code> and used to create clickable links that will change the URL without actually reloading the page like an a tag does.  The change in URL will cause the top level router component to rerender, and thouse the routes within it will rerender and be responsive to the new url.  Link components take a 'to' prop equal to the relative location to go to, and also a child that is the displayed link text on the page.  There is also a similar NavLink component you can import from the react-router-dom library.  It behaves the same and has a to attibute, but additionally when the url matches the to prop of a NavLink, then the NavLink will be given a class of 'active'.  This is most useful for navigational headings where you could now have a css rule for the active class to style it differently.  Optionally there is also an activeClassName prop that you can give to NavLinks, whose value should be a class name or set of class names that you want the component to have when it is active, and is again useful for stylin, if the deafult active class isn't enough for some reason.  So, your App component might render a Header component that renders a list of Link components.  The header component needs to import the link componets and the return of the header component might be:
        <code>
            <pre>
            return (
                &ltheader>
                    &ltnav>
                        &ltul>
                        &ltli>&ltNavLink to='/'>Home&lt/NavLink>&lt/li>
                        &ltli>&ltNavLink to='/roster'>Roster&lt/NavLink>&lt/li>
                        &ltli>&ltNavLink to='/schedule'>Schedule&lt/NavLink>&lt/li>
                        &lt/ul>
                    &lt/nav>
                &lt/header>
            );
            </pre>
        </code></li>
        <ul>
            <li><strong>Redirect</strong> Somewhat similar to Link and NavLink, there is a component called Redirect that you can import with <code>import { Redirect } from 'react-router-dom'</code>. It is a self-closing component tag, with a single <code>to</code> prop that you provide a url value similar to how you would a Link or NavLink.  When the Redirect component is rendered, it immediately changes the url to that relative path.  So, it is like a Link or NavLink that you don't have to click on, it changes the relative path immediately when rendered.  This is useful for example, if you have a User Profile component that renders user info, and it has a prop called isLoggedIn that is true or false.  Well, before the Profile component's normally rendered jsx, you could have an if statement that check if the isLoggedIn is true, and if not, then it renders a <code>&ltRedirect to='/sign-up' /></code> component that will immediately change the url to '/sign-up' so the user never see the profile page and instead the app renders the sign-up page (assuming there is a Route in app.js configured to render a sign up component when the path is '/sign-up'.  Another way to accomplish redirection is with the useHistory hook, explained below.</li>
        </ul>
        <li><strong>Dynamic Routing and useParams</strong> The path prop of a Route component can contain placeholders to create dynamic routing.  Placeholder are preceded by a colon, and you can have multiple placeholders in the path.  For example, you could give a Route component the path <code>/articles/:title</code>, which will match when the url is www.example.com/articles/anytitlehere.  Now, this placeholder will be available to you in the component the Route renders.  If the rendered component is a function component, then you need to import useParams from react-router-dom in the rendered component to access the placeholder values.  useParams is a function you call in the component, and it returns an object with keys that are the names of the placeholders and values that are the actual values for the placholders in the url.  In the article example, say you have an Article component that gets rendered by the Route when it is matched.  Then, in the article component (say it's a function component) you would import the useParams hook at the top, then in the actual component function definition, you would call it and save the placeholder to a variable, e.g. <code>const {title} = useParams();</code>.  Once you have the actual value of the url stored in the title variable, you could then use it in some logic in the component, such as looking up that article title in an array of articles, to get the right article to display in the return statement.  The component rendered by Route may contain its own switch and route components that render some other components based on more exact match criteria.  Some of this match criteria may be saved as parameters that are passed to the rendered component as props in the rendered component's props.match.params object.  Another example, <code>path='/roster/:number'</code> will save '6' to match.params.number if the url matches e.g. 'https://www.example.com/roster/6.  This is useful to use in the rendered component to e.g. make a call to an API for a specific player number.  So, the roster component might render either a full roster or a specific player based on the path match, and would import both switch and route, note the exact match is important so that switch skips it if there is more info after roster like roster/6.  the returned jsx might be: 
        <code><pre>
        &ltSwitch>
            &ltRoute exact path='/roster' component={FullRoster}/>
            &ltRoute path='/roster/:number' component={Player}/>
        &lt/Switch>
        </pre></code>
        And your FullRoster component might contain a list of all the players with Link Components that have dynamic 'to' props e.g. &ltli key={player.number}>&ltLink to=`/roster/${player.number}`>{player.name}&lt/Link&lt/li></code>.  And your Player component would render specific player information using match.params.number that gets passed to it when it is rendered by the Roster component.
        </li>        
        <li><strong>Switch and Exact: </strong>If you have multiple sibling Route components, for example in your top-level app.js file, then Router will render every Route component that matches, not just the first match.  So, if you have a route with path '/articles/new' and another with '/articles/:title' to render one component used to post new articles, and another to display current articles by title, they will both render if the url is '/articles/new' because new will also count in the :title placeholder.  Sometimes this is what you want, like if a particular url should render a certain main content component and a sidebar component for that url, then you want multiple routes to match that url, so all the components for that url render.  However, you often don't want this behavior like in the article example, and one option is to use the Switch component, which you wrap all your Route components in, and it will go through them top to bottom and render the first one that matches.  The switch component must be imported with <code>import { Switch } from 'react-router-dom';</code>.  Note that the order of the Routes within the Switch component is important, in our example you need to have the '/articles/new' route come first, or else you will always match the '/articles/:title' route first, even when the url is /articles/new.  Another important feature for controlling routes is the 'exact' attribute.  By default, a route will match the url if the url merely contains the path.  So, if you have a route that is simply '/articles', then the urls '/articles', '/articles/new', '/articles/mytitle' will all match this route. You can include in the route component the keyword 'exact' (like another prop with no value see example below) so that the url must match the path exactly, and only '/articles' will match that route, not the others.  So for another example, your app component, below the header, might render a Main component.  Inside the Main component you might have <code>import { Route, Switch } from 'react-router-dom'</code>.  You main component might import three other cmoponents that it renders conditionally.  Note the exact is necessary on Home because it will only render home on an exact match and if there is anything after the / like /roster, it will skip Home and look at the next route.  The render return in main might be: <code><pre>
        &ltmain>
            &ltSwitch>
                &ltRoute exact path='/' component={Home}/>
                &ltRoute path='/roster' component={Roster}/>
                &ltRoute path='/schedule' component={Schedule}/>
            &lt/Switch>
        &lt/main>
        </pre></code> </li>
        <li><strong>Nested Routing</strong> A first approach to routing is create the Router component in your top-level app.js file, and have all your routes listed as children of the router, with their respective paths and child components that they render when matched.  This always works but it can help keep your code better organized to move some of the Route components out of your app.js and into sub-components that get rendered by App.js.  For example, you might have a categories component that is imported into app.js and is wrapped in a Route component with a path of <code>'/categories'</code>.  Then you have a category component that lists all the articles belonging to a particular category.  You could have a Route in app.js that renders the category component with a path of <code>'/categories/:name</code> and then you would get the name placeholder with e.g. useParams() in the category component so you can filter your array of articles down to those in the particular category.  However, for better organization you could take that Route out of app.js and instead put it in the categories component.  The categories component will contain Link components that change the url to /categories/category-name for each category-name.  After the code that renders those links, you could include a Route component with a path of <code>'/categories/:name</code> that will render the category component.  Thus when you click a category link, the app rerenders with /categories/category-name for the url, which will still match /categories (don't make that route exact!) so the categories component will render, and then within the categories component, you will match the Route that will render the category component, which in turn will use useParams() to render the correct category.  Of course, the categories component now needs to import the category component and the Route component from the react router library and the app.js file no longer needs to import the category component.  Note this setup assumes you want to render categories and category at the same time, so it behaves like category pops into existence on the categories page and changes as you click links.  Note the benefit that the category component isn't rendered until it is called which is just a general good efficiency of React, as opposed to vanilla js perhaps you would render all the categories and show/hide them as needed.</li>
        <ul>
            <li><strong>useRouteMatch</strong> With nested routing, within the component that has nested routes (i.e. not app.js but one of the components it renders which has its own routes), it is often helpful to have access to the current url and matching path that got you to that component.   Within a nested function component, you can get this with <code>const { path, url } = useRouteMatch()</code>, but first you must import useRouteMatch from react-router-dom at the top of the file.  useRouteMatch() will return the so-called match object.  So, this is using destructured assignment to get the path and url properties of the match object.  The path object is the nested component's matching path with placeholders (i.e. it is the value of the path prop in the Route component in app.js that got you to this component), and it is designed to be used in the path prop of Route components within your nested component.  The url is the actual url of the nested component, with no placeholder, and it is designed to be used in the to prop of Link/NavLink components in your nested component.  SO, for example, say your app.js has a Route component with a path of '/band/:bandname', and it renders a component called Band.  So, the url www.example.com/band/beatles would match this Route, and thus the Band component would render.  Within the Band component, you could use <code>const {bandname} = useParams();</code> to get the bandname, and let say you then render a list of Links of that band's songs, by mapping over an array of songs that you filter based on the bandname.  Each Link has a to prop of '/band/beatles/song/songname', where the songname is the name of the song for that link, like '/band/beatles/song/help'.  Well, to get those values, you can use <code>`${url}/song/${songname}`</code>, where url is the value returned by useRouteMatch and equals '/band/beatles', and songname is the name of each song from the array of songnames your are mapping over to create the Links.  This allows for dynamic creation of the to props, so different band automatically will create the right to props.  Now, lets say you have a Route component in your band component that renders a Song component, where the Route has a path of '/band/:bandname/song/:song'.  Well here to create the path, you can use <code>`${path}/song/:song`</code>, where path is again from the useRouteMatch(), and will dynamically change with the band page you are on, so '/band/beatles' in this example.  The Route component will render every time you click the Links made above, each with a different value for the <code>:song</code> placeholder.  Inside this Route, you may render a Song component, that has information about the song, and within which you might use useParams to get the value of the <code>:song</code> placeholder to get the correct information.</li>
        </ul>
        <li><strong>routes.js</strong> You may want to store your route paths in their own file. In a react-redux app, a routes.js file may be placed in the app folder alongside App.js and store.js.  This file exports as default an object called ROUTES.  It contains keys describing each route, e.g. newQuizRoute, quizRoute, quizzesRoute, newTopicRoute, etc.  Each key is set to a function that returns a string that would be used e.g. in the to attribute for a Link component.  Most of the time the functions would have no parameter, but you might also give them a parameter like id might be used in <code>quizRoute: (id) => `/quizzes/${id}`</code>, so you can pass an id in to get the correct route.  You would import this file as ROUTES to your components and invoke the functions (with or without an argument as needed) to return the route, e.g <code>&ltNavLink to={ROUTES.topicsRoute()} activeClassName="active"></code></li>
        <li><strong>useHistory: </strong>This method can be imported from the library with <code>import { useHistory } from 'react-router-dom';</code> and among other things can be handy to force a change to the url.  For example after a form is submitted you might want to redirect the user to another page.  This can be done with first creating a history variable <code>const history = useHistory();</code>.  Then you can call <code>history.push('/myRoute');</code>.  For instance, you might render a form, with opening tag, <code>&ltform onSubmit={handleSubmit} /></code>, and then before your return statement that renders this form, you have <code>const history = useHistory();</code> and then define <code>const handleSubmit = e => {e.preventDefault(); history.push('/thankyou');}</code>.  Thus when the form is submitted, the default submission behavior will be prevented, and the use will immediately be redirected to 'www.example.com/thankyou', which maybe is a special component thanking them for filling out the form.  The useHistory object also has history.goBack(), and a history.goForward(), and a history.go(n) which takes a negative or positive integer with number of steps in history to go back or forward.  This could be used to make forward and back buttons.</li>
        <li><strong>useLocation: </strong>This can be imported with <code>import {useLocation} from 'react-router-dom'</code>.  It allows you to access query parameters in your url.  For instance, you might have a url that has a sorting query parameter, you could use useLocation as below to get it.  It gets the 'search' property from the object returned by useLocation.  This property's value is a string that is the query parameters of the url, e.g. <code>'?order=desc&name=ben</code>.  Next you can use the built in URLSearchParams class to turn that string into an object, with key/value pairs equal to the query parameter string's key/value pairs.  This object will have a get method you should use to get the value of the query parameter you want, as shown here.  This value can then be used in your logic.
        <code><pre>
            import { useLocation } from 'react-router-dom'
            
            // Rendered when a user visits "/list?order=DESC"
            export const SortedList = (numberList) => {
                const { search } = useLocation();
                const queryParams = new URLSearchParams(search);
                const sortOrder = queryParams.get('order');
                
                if (sortOrder === 'ASC') {
                    // render the numberList in ascending order
                } else if (sortOrder === 'DESC') {
                    // render the numberList in descending order
                } else {
                    // render the numberList as is
                }
            }
        </pre></code>
        </li>
    </ul>

</body>
</html>