<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Router</title>
</head>
<body>
    <a href="../index.html">Home</a>
    <h1>React Router</h1>
    <ul>
        <li>React Router is a popular library to use with react to create "multi-page" react apps or client-side routing. For web development it should be installed in the root folder of your app using <code>npm install react-router-dom</code> to save it to production dependencies (default when no flag used with npm install). </li>
        <li><strong>Router: </strong>Typically you will create a router component at the top level of your app and render your entire app as a child of the router component (the router child must have only one top-level jsx element).  All other components of this library must be decendents of the router component to work.  The router component creates a history object that keeps track of the URL and re-renders whenever the URL changes. To use the Router you must include <code>import { BrowserRouter } from 'react-router-dom';</code> at the top of the file (often the alias as Router is added).  You can alternatively import and use <code>HashRouter</code> if the server you are using can only render static pages (BrowserRouter is for servers that can handle dynamic requests).  A typical setup would be to import Browser Router in your index.js file, and render your App.js component as a child of it like below (of course also importing React, ReactDOM and the App component, along with any other imports).  However, you could also just include the Router component in your App component, and index.js will still just render your App component.  IN this case, the App component, would render the Router Component, and it's child would be maybe a top level div containing everything else in the App.
        <code>
            ReactDOM.render(
                &ltBrowserRouter>
                    &ltApp />
                &lt/BrowserRouter>
            )
        </pre></code></li>
        <li><strong>Link: </strong>The link component can be imported with <code>import { Link } from 'react-router-dom';</code> and used to create clickable links that will change the URL without actually reloading the page, however the change in URL will cause the top level router component to rerender the page.  Link components take a 'to' prop equal to the relative location to go to, and a child of the displayed link text.  There is also a similar NavLink component you can import from the react-router-dom library.  It has a to attibute but also an activeClassName attribute that you can provide a class name to for styling when the location in 'to' is the current location.  So, your App component might render a Header component that renders a list of Link components.  The header component needs to import the link componets and the return of the header component might be:
        <code>
            <pre>
            return (
                &ltheader>
                    &ltnav>
                        &ltul>
                        &ltli>&ltLink to='/'>Home&lt/Link>&lt/li>
                        &ltli>&ltLink to='/roster'>Roster&lt/Link>&lt/li>
                        &ltli>&ltLink to='/schedule'>Schedule&lt/Link>&lt/li>
                        &lt/ul>
                    &lt/nav>
                &lt/header>
            );
            </pre>
        </code></li>
        <li><strong>Route: </strong> When you want to render a component conditionally on the URL, you use the Route component.  It must be imported with <code>import { Route } from 'react-router-dom';</code> The route component takes a path prop set to a string value of the pathname to match, note it matches everything after the top level domain (e.g. everything after .com) but everything before any query parameters or fragment identifiers (i.e. everything before ? or #).  You can include the 'exact' attribute in the route component to make the path match exact, otherwise it will match if the URL merely contains the specified path.  It also takes a component prop set to the injected component name (the component must be imported into the file). When rendered this component will automatically be passed a 'location' prop, the 'history' prop, and a 'match' prop.  The match prop is an object with a 'url', 'path', 'isExact', and 'params' property.  Instead of a component prop, the Route component can use the 'render' prop which takes an injected function that has a props argument for the automatically passed props, and is useful if additional props are needed.  e.g. <code>&ltRoute path='/page' render={(props) => (&ltPage {...props} data={{extraProp: 'propValue'}}/>)} /></code> or instead of rendering a component it can render some html-like jsx directly if a full component isn't needed, e.g. <code>render={()=>(&lth1>Welcome&lth1>)}</code>.  Finally, you can also include the component to render as a child of Route, and make the Route component not self-closing.  When the component is a child you can include prop attributes like normal.</li>

        <li><strong>Switch: </strong>You'll often have a main component that renders other components conditionally based on the url, and it is useful to use the Switch component which will go through Route components and render the first one that matches.  The switch component must be imported with <code>import { Switch } from 'react-router-dom';</code>. So, your app component, below the header, might render a Main component.  Inside the Main component you might have <code>import { Route, Switch } from 'react-router-dom'</code>.  You main component might import three other cmoponents that it renders conditionally.  Note the exact is necessary on Home because it will only render home on an exact match and if there is anything after the / like /roster, it will skip Home and look at the next route.  The render return in main might be: <code><pre>
        &ltmain>
            &ltSwitch>
                &ltRoute exact path='/' component={Home}/>
                &ltRoute path='/roster' component={Roster}/>
                &ltRoute path='/schedule' component={Schedule}/>
            &lt/Switch>
        &lt/main>
        </pre></code> </li>
        <li><strong>Dynamic Routing</strong> A component rendered by Route may contain its own switch and route components that render some other components based on more exact match criteria.  Some of this match criteria may be saved as parameters that are passed to the rendered prop through the match.params object.  To save a part of the match as a parameter you use a colon, like <code>path='/roster/:number'</code> will save '6' to match.params.number if the url matches e.g. 'https://www.example.com/roster/6.  This is useful to use in the rendered component to e.g. make a call to an API for a specific player number.  So, the roster component might render either a full roster or a specific player based on the path match, and would import both switch and route, note the exact match is important so that switch skips it if there is more info after roster like roster/6.  the returned jsx might be: 
        <code><pre>
        &ltSwitch>
            &ltRoute exact path='/roster' component={FullRoster}/>
            &ltRoute path='/roster/:number' component={Player}/>
        &lt/Switch>
        </pre></code>
        And your FullRoster component might contain a list of all the players with Link Components that have dynamic 'to' props e.g. &ltli key={player.number}>&ltLink to=`/roster/${player.number}`>{player.name}&lt/Link&lt/li></code>.  And your Player component would render specific player information using match.params.number that gets passed to it when it is rendered by the Roster component.
        </li>

</body>
</html>